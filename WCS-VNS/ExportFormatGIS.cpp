// ExportFormatGIS.cpp
// Code module for GIS export code
// Created on 12/16/04 by FPW2
// Copyright 2004 3D Nature, LLC. All rights reserved.

#include "stdafx.h"
#include "ExportFormat.h"
#include "EffectsLib.h"
#include "ExportControlGUI.h"
#include "IncludeExcludeList.h"
#include "Raster.h"
#include "ImageOutputEvent.h"
#include "Project.h"
#include "Requester.h"
#include "AppMem.h"
#include "RasterResampler.h"
#include "Log.h"
#include "SceneExportGUI.h"
#include "SXExtension.h"
#include "Security.h"
#include "DBEditGUI.h"
#include "Shapefiles.h"

// Generated by BreakPoint Software's Hex Workshop v4.20
//   http://www.hexworkshop.com
//   http://www.bpsoft.com
//
//  Source File: GIS_Exporter_Foliage_Template.dbf
//         Time: 11/9/2005 1:02 PM
// Orig. Offset: 0 / 0x00000000
//       Length: 161 / 0x000000A1 (bytes)
unsigned char dbfData[161] =
{
    0x03, 0x69, 0x0B, 0x09, 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x49, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x49, 0x4D, 0x41, 0x47, 0x45, 0x4E, 0x41, 0x4D, 0x45, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 
    0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x48, 0x45, 0x49, 0x47, 0x48, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x00, 
    0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x49, 0x4D, 0x41, 0x47, 0x45, 0x4E, 0x41, 0x4D, 0x45, 0x32, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 
    0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x0D
}; // currently set to ID# (number)[5]/IMAGENAME (char)[80]/HEIGHT (number)[8.2]/IMAGENAME2 (char)[80]

extern bool GIS_Name_Warned;

ExportFormatGIS::ExportFormatGIS(SceneExporter *MasterSource, Project *ProjectSource, EffectsLib *EffectsSource, Database *DBSource, ImageLib *ImageSource)
: ExportFormat(MasterSource, ProjectSource, EffectsSource, DBSource, ImageSource)
{

fPaF.SetPath(Master->OutPath.Path);
fPaF.SetName("Foliage");

pPaF.SetPath(Master->OutPath.Path);
pPaF.SetName("Point");

vPaF.SetPath(Master->OutPath.Path);
vPaF.SetName("Vector");

} // ExportFormatGIS::ExportFormatGIS

/*===========================================================================*/
ExportFormatGIS::~ExportFormatGIS()
{

} // ExportFormatGIS::~ExportFormatGIS

/*===========================================================================*/
int ExportFormatGIS::PackageExport(NameList **FileNamesCreated)
{
FILE *fOut = NULL;
int Success = 1;
long FileType;
//long PatternIndex = 0;
PathAndFile PaF;
char TempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];
const char *OutputFilePath;
class OF_ColorPalette CP;
class OF_VertexPalette VP;
JoeApproveHook LocalJoeApproveHook;
char NewPAFName[512], OldPAFName[512];
const char *IndexFileName;

if (GlobalApp->Sentinal->CheckAuthFieldSX2() == 0)
	return 0;

GIS_Name_Warned = false;	// init shapefile name warning flag

// The directory where all the files should be created is:
OutputFilePath = Master->OutPath.GetPath();

if (Master->ExportTerrain)
	{
	PaF.SetPath((char *)Master->OutPath.GetPath());
	PaF.SetName((char *)Master->OutPath.GetName());
	PaF.GetFramePathAndName(TempFullPath, ".raw", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
	if (fGrid = PROJ_fopen(TempFullPath, "rb"))
		{
		// the RAW DEM is renamed & becomes the ESRI DEM
		fclose(fGrid);
		strcpy(OldPAFName, TempFullPath);
		PaF.GetFramePathAndName(NewPAFName, ".flt", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		if (fOut = PROJ_fopen(NewPAFName, "r"))
			{
			fclose(fOut);
			PROJ_remove(NewPAFName);
			}; // if
		PROJ_rename(OldPAFName, NewPAFName);
		// create the header for the DEM
		PaF.GetFramePathAndName(TempFullPath, ".hdr", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		if (fOut = PROJ_fopen(TempFullPath, "w"))
			{
			//double cellsize;

			Master->RBounds.DeriveCoords(Master->DEMResY, Master->DEMResX);
			fprintf(fOut, "ncols         %d\n", Master->DEMResX);
			fprintf(fOut, "nrows         %d\n", Master->DEMResY);
			//*** RBounds & it's GeoReg & values is different than GeoReg, so we can't do this the "easy" way right now - fixed?
			fprintf(fOut, "xllcorner     %f\n", Master->RBounds.ULcorner.x);
			fprintf(fOut, "yllcorner     %f\n", Master->RBounds.LRcorner.y);
			if (fabs((Master->RBounds.CellSizeX - Master->RBounds.CellSizeY)) < 0.00001)	// if they're equal
				{
				fprintf(fOut, "cellsize      %f\n", Master->RBounds.CellSizeX);
				} // if
			else
				{
				// older software may not support these fields - user should ensure they're equal if it's a problem for them
				fprintf(fOut, "xdim      %f\n", Master->RBounds.CellSizeX);
				fprintf(fOut, "ydim      %f\n", Master->RBounds.CellSizeY);
				} // else
			//***/
			/*** workaround not needed now
			cellsize = (Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_NORTH].CurValue - Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_SOUTH].CurValue) /
				(Master->DEMResY - 1);
			fprintf(fOut, "xllcorner     %f\n", Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_WEST].CurValue - (cellsize * 0.5));
			fprintf(fOut, "yllcorner     %f\n", Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_SOUTH].CurValue - (cellsize * 0.5));
			fprintf(fOut, "cellsize      %f\n", cellsize);
			***/
			// CellSizeY
			//fprintf(fOut, "NODATA_value\n");
			fprintf(fOut, "byteorder     LSBFIRST\n");
			fclose(fOut);
			} // if fOut
		PaF.GetFramePathAndName(TempFullPath, ".prj", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		if (Master->RBounds.MyCoords && (fOut = PROJ_fopen(TempFullPath, "w")))
			{
			Master->RBounds.MyCoords->SaveToArcPrj(fOut);
			fclose(fOut);
			} // if fOut
		} // if fGrid
	else
		Success = 0;
	} // if ExportTerrain

Master->RBounds.DeriveCoords(Master->TexResY, Master->TexResX);
FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	strcpy(TempFullPath, IndexFileName);
	StripExtension(TempFullPath);
	strcat(TempFullPath, ".tfw");
	if (fOut = PROJ_fopen(TempFullPath, "w"))
		{
		fprintf(fOut, "%f\n", Master->RBounds.CellSizeX);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", -Master->RBounds.CellSizeY);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.x);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.y);
		fclose(fOut);
		} // if fOut
	} // if Tex1

FileType = WCS_EXPORTCONTROL_FILETYPE_TEX2;
if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	strcpy(TempFullPath, IndexFileName);
	StripExtension(TempFullPath);
	strcat(TempFullPath, ".tfw");
	if (fOut = PROJ_fopen(TempFullPath, "w"))
		{
		fprintf(fOut, "%f\n", Master->RBounds.CellSizeX);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", -Master->RBounds.CellSizeY);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.x);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.y);
		fclose(fOut);
		} // if fOut
	} // if Tex2

if (Success && Master->ExportVectors)
	{
	int FlipLon = 1;

	LocalJoeApproveHook.ObjectThis = GlobalApp->AppDB->StaticRoot;
	LocalJoeApproveHook.Approve = DBEditJoeApprove;
	LocalJoeApproveHook.ExportDEMsAs = WCS_DBEXPORT_DEMSAS_POLYFACEMESH;	// This field isn't relevant to our export
	LocalJoeApproveHook.ExportObjects = WCS_DBEXPORT_OBJECTS_RENDERENABLED;

	// Export vectors to Shapefiles
	// DBF consists of a Vector Name field, plus columns for any attribute fields
	LocalJoeApproveHook.ExportClasses = WCS_DBEXPORT_CLASS_VECTORS | WCS_DBEXPORT_CLASS_CONTROLPTS;
	Success = GlobalApp->AppDB->ExportShape(GlobalApp->MainProj, &LocalJoeApproveHook, Master->RBounds.MyCoords, 1.0, 1.0, FlipLon,
		1, 0, 0.0, &Master->RBounds, 0, pPaF.Path, pPaF.Name);	// points only
	if (Success)
		{
		LocalJoeApproveHook.ExportClasses = WCS_DBEXPORT_CLASS_VECTORS;
		Success = GlobalApp->AppDB->ExportShape(GlobalApp->MainProj, &LocalJoeApproveHook, Master->RBounds.MyCoords, 1.0, 1.0, FlipLon,
			1, 0, 0.0, &Master->RBounds, 1, vPaF.Path, vPaF.Name);	// vectors only
		} // if
	LocalJoeApproveHook.ObjectThis = NULL;
	} // if ExportVectors

if (Success && Master->ExportFoliage)
	Success = ProcessFoliageList(FileNamesCreated, OutputFilePath);

Cleanup(OutputFilePath, FileNamesCreated);

return (Success);

} // ExportFormatGIS::PackageExport

/*===========================================================================*/

int ExportFormatGIS::ProcessFoliageList(NameList **FileNamesCreated, const char *OutputFilePath)
{
//double BBot, BLeft, BRight, BTop;
double ExportX, ExportY;
double ref_x, ref_y, ref_z;
FILE *ffile;
//static long TreeNum = 0;	// for labeling tree LOD's
long DatPt, FileType;
//long WriteFol = 0;
//short *XlateTable = NULL;
int Success = 1;
const char *IndexFileName, *DataFileName;
RealtimeFoliageIndex Index;
RealtimeFoliageCellData RFCD;
RealtimeFoliageData FolData;
//char TempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];
//char fName[WCS_PATHANDFILE_PATH_LEN + WCS_PATHANDFILE_NAME_LEN];
char FileName[512];
char TestFileVersion;

ref_x = Master->ExportRefData.ExportRefLon;
ref_y = Master->ExportRefData.ExportRefLat;
ref_z = Master->ExportRefData.RefElev;

fPaF.SetPath((char *)Master->OutPath.GetPath());

// files may not exist. If they don't then user must not have chosen foliage export features
FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
	if (DataFileName = (*FileNamesCreated)->FindNameOfType(FileType))
		{
		// you've got the two file names that the Renderer wrote out.
		// combine them with the output file path to make a file that can be opened with PROJ_fopen()

		// find and open the index file
		strmfp(FileName, OutputFilePath, IndexFileName);
		if (ffile = PROJ_fopen(FileName, "rb"))
			{
			// read file descriptor, no need to keep it around unless you want to
			fgets(FileName, 256, ffile);
			// version
			fread((char *)&Index.FileVersion, sizeof(char), 1, ffile);
			// number of files
			fread((char *)&Index.NumCells, sizeof(long), 1, ffile);
			// reference XYZ
			fread((char *)&Index.RefXYZ[0], sizeof(double), 1, ffile);
			fread((char *)&Index.RefXYZ[1], sizeof(double), 1, ffile);
			fread((char *)&Index.RefXYZ[2], sizeof(double), 1, ffile);

			if (Index.NumCells > 0)
				{
				// only one cell data entry is provided
				if (Index.CellDat = &RFCD)
					{
					// file name
					fgets(Index.CellDat->FileName, 64, ffile);
					// center XYZ
					fread((char *)&Index.CellDat->CellXYZ[0], sizeof(double), 1, ffile);
					fread((char *)&Index.CellDat->CellXYZ[1], sizeof(double), 1, ffile);
					fread((char *)&Index.CellDat->CellXYZ[2], sizeof(double), 1, ffile);
					// half cube cell dimension
					fread((char *)&Index.CellDat->CellRad, sizeof(double), 1, ffile);
					// number of trees in file
					fread((char *)&Index.CellDat->DatCt, sizeof(long), 1, ffile);
					} // if
				} // if some cells to read
			fclose(ffile);

			if ((Index.NumCells > 0) && (Index.CellDat->DatCt > 0))
				{
				strmfp(FileName, OutputFilePath, DataFileName);
				if (ffile = PROJ_fopen(FileName, "rb"))
					{
					fgets(FileName, 64, ffile);
					// version
					fread((char *)&TestFileVersion, sizeof(char), 1, ffile);
					// Pointless version check -- we know we wrote it
					if (TestFileVersion == Index.FileVersion)
						{
						class Shapefile3D *Shape;
						FILE *fdBase;

						Shape = new Shapefile3D(SHP_PointZ);
						if (Shape)
							{
							Shape->Init((char *)fPaF.GetPath(), (char *)fPaF.GetName());
							fdBase = Shape->Get_dBase_Handle();
							if (fdBase)
								{
								fwrite(dbfData, 1, sizeof(dbfData), fdBase);	// write the Table File Header & Table File Descriptor
								// see if any foliage exists
								for (DatPt = 0; DatPt < Index.CellDat->DatCt; DatPt++)
									{
									if (FolData.ReadFoliageRecord(ffile, Index.FileVersion))
										{
										Raster *CurRast;
										long id;
										FoliagePreviewData PointData;
										// Don't touch these unless you change the dbfData!!!
										char ID_num[6];
										char ImageName[81];
										char Height[9];
										char ImageName2[81];

										FolData.InterpretFoliageRecord(NULL, GlobalApp->AppImages, &PointData);

										//if (FolData.BitInfo & WCS_REALTIME_FOLDAT_BITINFO_LABEL) // label
										//	printf("got it");

										if (Master->RBounds.IsGeographic)
											{
											ExportX = FolData.XYZ[0] + ref_x;
											ExportY = FolData.XYZ[1] + ref_y;
											} // if
										else
											{
											ExportX = FolData.XYZ[0] * Master->ExportRefData.ExportLonScale + ref_x;
											ExportY = FolData.XYZ[1] * Master->ExportRefData.ExportLatScale + ref_y;
											} // else
										Shape->SetX(ExportX);
										Shape->SetY(ExportY);
										Shape->SetZ(FolData.XYZ[2] * Master->ExportRefData.ElevScale + ref_z);
										Shape->WritePointZ();

										id = FolData.ElementID;

										memset(ID_num, 0x20, sizeof(ID_num));
										memset(ImageName, 0x20, sizeof(ImageName));
										memset(Height, 0x20, sizeof(Height));
										memset(ImageName2, 0x20, sizeof(ImageName2));
										if (CurRast = Images->FindByID(id))
											{
											long ndx;

											strncpy(ImageName, CurRast->GetUserName(), sizeof(ImageName));
											sprintf(ID_num, "%5d", FolData.ElementID);
											sprintf(Height, "%8.2f", PointData.Height);
											strncpy(ImageName2, CurRast->PAF.GetName(), sizeof(ImageName2));

											// strncpy zero filled our fields, but it's supposed to be filled with the space char
											ndx = sizeof(ImageName) - 1;
											do
												{
												ImageName[ndx] = 0x20;
												--ndx;
												}  while ((ndx > 0) && (ImageName[ndx] == 0));
											ndx = sizeof(ImageName2) - 1;
											do
												{
												ImageName2[ndx] = 0x20;
												--ndx;
												}  while ((ndx > 0) && (ImageName2[ndx] == 0));
											} // if
										fputc(0x20, fdBase);	// start a new record - indicate that it hasn't been deleted
										fwrite(ID_num, 1, sizeof(ID_num) - 1, fdBase);
										fwrite(ImageName, 1, sizeof(ImageName) - 1, fdBase);
										fwrite(Height, 1, sizeof(Height) - 1, fdBase);
										fwrite(ImageName2, 1, sizeof(ImageName2) - 1, fdBase);

										} // if
									} // for

								FILE *fPrj = NULL;
								strmfp(FileName, fPaF.GetPath(), fPaF.GetName());
								strcat(FileName, ".prj");
								if (Master->Coords && (fPrj = PROJ_fopen(FileName, "w")))
									{
									Master->Coords->SaveToArcPrj(fPrj);
									fclose(fPrj);
									} // if

								} // if fdBase
							else
								{
								char msg[512];

								sprintf(&msg[0], "Can't open %s\\%s.dbf", fPaF.GetPath(), fPaF.GetName());
								GlobalApp->StatusLog->PostError(WCS_LOG_SEVERITY_MSG, msg);
								Success = 0;
								} // else

							Shape->Wrapup();
							delete Shape;
							} // if Shape
						else
							Success = 0;

						} // if
					fclose(ffile);
					} // if
				} // if
			} // if
		} // if
	} // if

// must do this as it's not dynamically allocated and RealtimeFoliageIndex
// destructor will blow chunks if we don't
Index.CellDat = NULL;

return (Success);

} // ExportFormatGIS::ProcessFoliageList

/*===========================================================================*/

int ExportFormatGIS::SanityCheck(void)
{
int Success = 1;
long vWarn = 0;

// see if shapefile name is spec compliant
if (vPaF.Name[0])
	{
	if (strlen(vPaF.GetName()) > 8)
		vWarn = 1;
	if (! isalnum((int)vPaF.Name[0]))
		vWarn = 1;
	for (long i = 0; i < 8; i++)
		{
		int ch = vPaF.Name[i];

		if (ch == 0)
			break;
		if (!(isalnum(ch) || (ch == '_') || (ch == '-')))
			vWarn = 1;
		} // for
	} // if vPAF.Name
else
	vWarn = TRUE;

if (vWarn)
	{
	if (UserMessageYN("Invalid Shapefile Name", "The Shapefile name for Vector export isn't fully spec compliant.\n\nDo you wish to fix it?"))
		{
		char str[256];
		// this function won't guarantee a valid string, but they've been warned...
		GetInputString("The base file name must be 8 characters or less in length. The first character must be a letter or digit. \
Any additional characters must be a number, digit, the dash (-) or the underscore (_)", "~`!@#$%^&*()+={}[]|\\:;\"\'<,>.\?/", str);
		vPaF.SetName(str);
		} // if UserMessageYN

	if (vPaF.Name[0] == 0)
		vPaF.SetName(Master->OutPath.Name);
	} // if vWarn

return (Success);

} // ExportFormatGIS::SanityCheck

/*===========================================================================*/

// remove all temp files
void ExportFormatGIS::Cleanup(const char *OutputFilePath, NameList **FileNamesCreated)
{
const char *FileName;
long FileType;
char FullFileName[512];

// remove foliage temp files
FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
if (FileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	strmfp(FullFileName, OutputFilePath, FileName);
	PROJ_remove(FullFileName);

	FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
	if (FileName = (*FileNamesCreated)->FindNameOfType(FileType))
		{
		strmfp(FullFileName, OutputFilePath, FileName);
		PROJ_remove(FullFileName);
		} // if
	} // if

} // ExportFormatGIS::Cleanup

/*===========================================================================*/
