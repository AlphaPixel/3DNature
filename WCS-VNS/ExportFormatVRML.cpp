// ExportFormatVRML.cpp
// Code module for VRML export code
// Created from ExportFormat.cpp on 5/18/04 by CXH
// ExportFormat.cpp Created from scratch 07/01/03 by Gary R. Huber
// Copyright 2003 Questar Productions. All rights reserved.

#include "stdafx.h"
#include "ExportFormat.h"
#include "EffectsLib.h"
#include "ExportControlGUI.h"
#include "IncludeExcludeList.h"
#include "Raster.h"
#include "ImageOutputEvent.h"
#include "Project.h"
#include "Requester.h"
#include "TerrainWriter.h"
#include "CubeSphere.h"
#include "AppMem.h"
#include "RasterResampler.h"
#include "Log.h"
#include "SceneExportGUI.h"
#include "SXExtension.h"
#include "zlib.h"
#include "Lists.h"

/***

   VRML Axis:

   Y
   |
   *- X
  /
 Z

***/

/***

   Z-Corp Axis:

   Z Y
   |/
   *- X

***/

static bool X3D;

static int VRML_Header_WorldInfo(FILE *fVRML)
{
int rval;
TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
DWORD CNameSize;

if (X3D)
	fprintf(fVRML, "#X3D V3.0 utf8\n\nPROFILE Immersive\n\n");
else
	fprintf(fVRML, "#VRML V2.0 utf8\n\n");
CNameSize = sizeof(ComputerName);
if (!GetComputerName(ComputerName, &CNameSize))
	strcpy(ComputerName, "Unknown");
rval = fprintf(fVRML, "WorldInfo {\n title \"%s\"\n info [\n \"Generated by 3D Nature's Scene Express\"\n \"Created on %s\"\n \"Created by %s\"\n ]\n}\n\n",
	GlobalApp->MainProj->projectname, ComputerName, GlobalApp->MainProj->UserName);
return rval;
} // VRML_Header_WorldFile

/*===========================================================================*/

ExportFormatVRML::ExportFormatVRML(SceneExporter *MasterSource, Project *ProjectSource, EffectsLib *EffectsSource, Database *DBSource, ImageLib *ImageSource)
: ExportFormat(MasterSource, ProjectSource, EffectsSource, DBSource, ImageSource)
{

} // ExportFormatVRML::ExportFormatVRML

/*===========================================================================*/

ExportFormatVRML::~ExportFormatVRML()
{

} // ExportFormatVRML::~ExportFormatVRML

/*===========================================================================*/

int ExportFormatVRML::SanityCheck(void)
{
int Success = 1;

if (Master->ExportCameras)
	{
	class EffectList *CamList = Master->Cameras;
	class Camera *Cam;

	while (CamList)
		{
		Cam = (class Camera *)CamList->Me;
		if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_PLANIMETRIC)
			{
			UserMessageOK("VRML Export", "Planimetric Camera's can't be exported to VRML");
			Success = 0;
			} // if
		CamList = CamList->Next;
		} // while
	} // if Cameras

return (Success);

} // ExportFormatVRML::SanityCheck

/*===========================================================================*/

float ExportFormatVRML::AvgElev(FILE *RawElevs, long Cols, long Rows)
{
float sum = 0.0f, val;
long i, j = Cols * Rows, k = 0;

rewind(RawElevs);
for (i = 0; i < j; i++)
	{
	fread(&val, 1, 4, RawElevs);
	if (val != -9999.0f)
		{
		sum += val;
		k++;
		} // if
	} // for

if (k == 0)
	val = 0.0f;	// no values found
else
	val = sum / k;

return val;

} // ExportFormatVRML::AvgElev

/*===========================================================================*/

float ExportFormatVRML::MinElev(FILE *RawElevs, long Cols, long Rows)
{
float  min = FLT_MAX, val;
long i, j = Cols * Rows, k = 0;

rewind(RawElevs);
for (i = 0; i < j; i++)
	{
	fread(&val, 1, 4, RawElevs);
	if ((val != -9999.0f) && (val < min))
		min = val;
	} // for

if (min == -9999.0f)
	val = 0.0f;

return min;

} // ExportFormatVRML::MinElev

/*===========================================================================*/

// range notes are in VRML syntax (brackets are inclusive, parens are exclusive)
int ExportFormatVRML::PackageExport(NameList **FileNamesCreated)
{
double GeoCtrLon, GeoCtrLat, LonScale, X, Y;
float cx, cz, speed, sx, sz, xspace, zspace, xlate, ylate, zlate;
int Success = 1;
long DatPt, FileType, Tiles = 0, XTile, YTile;
long tilesizex, tilesizey;
const char *RawTerrainFile, *TextureFile, *OutputFilePath, *IndexFileName, *DataFileName, *CleanFileName;
FILE *fVRML = NULL;
FILE *fRaw = NULL, *fTexture = NULL, *ffile = NULL;
PathAndFile SceneOutput;
char TempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN]; //, TempFullPathB[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];
class TerrainWriter *TW = NULL;
RealtimeFoliageIndex Index;
RealtimeFoliageCellData RFCD;
RealtimeFoliageData FolData;
char FileName[512], TestFileVersion;
FoliagePreviewData PointData;
long AnimCams = 0, Illuminate3D = 0;
RasterAnimHostProperties Prop;
RenderData RendData(NULL);
RenderJob *RJob;
long EmitFlags, EmitFlaps;
float *MinTable = NULL;
float ElevAdjust;
unsigned long CoordsCount = 0;
char FullFileName[512];

if (!(RJob = new RenderJob))
	{
	Success = 0;
	GlobalApp->StatusLog->PostError(WCS_LOG_SEVERITY_ERR, "VRML Export aborted - critically short on memory!");
	goto Cleanup;
	} // if

if (GlobalApp->MainProj->Prefs.PrivateQueryConfigOpt("VRMLinX3D"))
	X3D = true;
else
	X3D = false;

RendData.FrameRate = GlobalApp->MainProj->Interactive->GetFrameRate();
RendData.Width = 1024;
RendData.Height = 768;

// The directory where all the files should be created is:
OutputFilePath = Master->OutPath.GetPath();

SceneOutput.SetPath((char *)Master->OutPath.GetPath());
SceneOutput.SetName((char *)Master->OutPath.GetName());
//if (Master->ZipItUp)
//	SceneOutput.GetFramePathAndName(TempFullPath, ".wrz", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
//else
if (X3D)
	SceneOutput.GetFramePathAndName(TempFullPath, ".x3dv", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
else
	SceneOutput.GetFramePathAndName(TempFullPath, ".wrl", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);

// grh modified coords
//GeoCtrLon = -(Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_WEST].CurValue + Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_EAST].CurValue) / 2.0;
//GeoCtrLat = (Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_NORTH].CurValue + Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_SOUTH].CurValue) / 2.0;
//LonScale = cos(GeoCtrLat * PiOver180);
GeoCtrLon = Master->ExportRefData.ExportRefLon;
GeoCtrLat = Master->ExportRefData.ExportRefLat;
LonScale = Master->ExportRefData.ExportLonScale;
ElevAdjust = (float)(-Master->ExportRefData.RefElev);

if ((Master->DEMTilesX > 1) || (Master->DEMTilesY > 1))
	{
	Tiles = 1;
	FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	RawTerrainFile = NULL;
	RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
	fRaw = PROJ_fopen(RawTerrainFile, "rb");

	FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
	TextureFile = NULL;
	TextureFile = (*FileNamesCreated)->FindNextNameOfType(FileType, TextureFile);

	tilesizex = (long)((Master->DEMResX + Master->DEMTilesX - 1) / Master->DEMTilesX);
	tilesizey = (long)((Master->DEMResY + Master->DEMTilesY - 1) / Master->DEMTilesY);
	} // if tiles
else
	{
	FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	RawTerrainFile = (*FileNamesCreated)->FindNameOfType(FileType);
	fRaw = PROJ_fopen(RawTerrainFile, "rb");

	FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
	TextureFile = (*FileNamesCreated)->FindNameOfType(FileType);
	tilesizex = Master->DEMResX;
	tilesizey = Master->DEMResY;
	} // else tiles

strcpy(TempFullPath, GlobalApp->MainProj->MungPath(TempFullPath));
fVRML = fopen(TempFullPath, "w+");	// w+ ???

if (TW = new TerrainWriter)
	{
	TW->EmitType = WCS_TERRAINWRITER_ASCII;
	} // if TW

if (fVRML && TW)
	{
	const char *SkyURL;

	// grh modifed coords
	//if (Master->RBounds.IsGeographic)
	//	{
	//	double tmpx, tmpz;

	//	tmpx = Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_WEST].CurValue - Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_EAST].CurValue;
	//	tmpz = Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_NORTH].CurValue - Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_SOUTH].CurValue;
	//	xspace = (float)(tmpx * EARTHLATSCALE_METERS / Master->DEMResX * LonScale);
	//	zspace = (float)(tmpz * EARTHLATSCALE_METERS / Master->DEMResY);
	//	sx = (float)((Master->DEMResX - 1) * xspace);
	//	sz = (float)((Master->DEMResY - 1) * zspace);
	//	} // if
	//else
	//	{
	//	xspace = (float)Master->RBounds.CellSizeX;
	//	zspace = (float)Master->RBounds.CellSizeY;
	//	sx = (float)((Master->DEMResX - 1) * Master->RBounds.CellSizeX);	// size x
	//	sz = (float)((Master->DEMResY - 1) * Master->RBounds.CellSizeY);
	//	} // else
	xspace = (float)(Master->RBounds.CellSizeX * Master->ExportRefData.ExportLonScale);
	zspace = (float)(Master->RBounds.CellSizeY * Master->ExportRefData.ExportLatScale);
	sx = (float)(((Master->DEMResX - 1) * Master->RBounds.CellSizeX) * Master->ExportRefData.ExportLonScale);	// size x
	sz = (float)(((Master->DEMResY - 1) * Master->RBounds.CellSizeY) * Master->ExportRefData.ExportLatScale);
	cx = sx * 0.5f;	// center x
	cz = sz * 0.5f;

	if (sx > sz)
		speed = (float)sx;
	else
		speed = (float)sz;
	speed /= 7.0f;	// no more than 7 seconds to cross our terrain

	VRML_Header_WorldInfo(fVRML);

	// embed some georeferincing info into some comments
	fprintf(fVRML, "# SouthWest corner X = %lf\n", Master->RBounds.ULcorner.x);
	fprintf(fVRML, "# SouthWest corner Y = %lf\n", Master->RBounds.LRcorner.y);
	fprintf(fVRML, "# Center Reference X = %lf\n", Master->ExportRefData.ExportRefLon);
	fprintf(fVRML, "# Center Reference Y = %lf\n", Master->ExportRefData.ExportRefLat);
	fprintf(fVRML, "# Center Reference Z = %lf\n", Master->ExportRefData.RefElev);

	fprintf(fVRML, "\nNavigationInfo {\n headlight FALSE\n speed %f\n type [\"FLY\", \"ANY\"]\n}\n", speed);

	// Background
	FileType = WCS_EXPORTCONTROL_FILETYPE_SKYSOUTH;
	if (SkyURL = (*FileNamesCreated)->FindNameOfType(FileType))
		{
		fprintf(fVRML, "\nBackground \n{\n backUrl \"%s\"\n", SkyURL);
		FileType = WCS_EXPORTCONTROL_FILETYPE_SKYBOTTOM;
		SkyURL = (*FileNamesCreated)->FindNameOfType(FileType);
		fprintf(fVRML, " bottomUrl \"%s\"\n", SkyURL);
		FileType = WCS_EXPORTCONTROL_FILETYPE_SKYNORTH;
		SkyURL = (*FileNamesCreated)->FindNameOfType(FileType);
		fprintf(fVRML, " frontUrl \"%s\"\n", SkyURL);
		FileType = WCS_EXPORTCONTROL_FILETYPE_SKYWEST;
		SkyURL = (*FileNamesCreated)->FindNameOfType(FileType);
		fprintf(fVRML, " leftUrl \"%s\"\n", SkyURL);
		FileType = WCS_EXPORTCONTROL_FILETYPE_SKYEAST;
		SkyURL = (*FileNamesCreated)->FindNameOfType(FileType);
		fprintf(fVRML, " rightUrl \"%s\"\n", SkyURL);
		FileType = WCS_EXPORTCONTROL_FILETYPE_SKYTOP;
		SkyURL = (*FileNamesCreated)->FindNameOfType(FileType);
		fprintf(fVRML, " topUrl \"%s\"\n}\n", SkyURL);
		} // if

	// Viewpoints
	if (Master->ExportCameras)
		{
		class EffectList *CamList = Master->Cameras;
		class Camera *Cam;

		while (CamList)
			{
			Point4d AxisAngle;
			Point3d Orient;
			//double rot;
			float LookAt[3], LookFrom[3];
			long AnimCam;

			Cam = (class Camera *)CamList->Me;
			// check to see if this camera is animated
			Prop.PropMask = (WCS_RAHOST_MASKBIT_FLAGS);
			Prop.FlagsMask = WCS_RAHOST_FLAGBIT_ANIMATED;
			Prop.ItemOperator = WCS_KEYOPERATION_ALLKEYS;
			Prop.TypeNumber = WCS_EFFECTSSUBCLASS_CAMERA;
			Cam->GetRAHostProperties(&Prop);
			AnimCam = 0;
			if (Prop.Flags & WCS_RAHOST_FLAGBIT_ANIMATED)
				{
				fprintf(fVRML, "\nDEF ANIMCAM%d Viewpoint {\n", AnimCams);
				AnimCam = 1;
				}
			else
				fprintf(fVRML, "\nViewpoint {\n");
			LookAt[0] = LookAt[1] = LookAt[2] = 0.0f;
			// convert geographic position to meters & our repositioning
			// grh modified coords
			//LookFrom[0] = (float)((-Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLON].CurValue - GeoCtrLon) * EARTHLATSCALE_METERS);
			//LookFrom[1] = (float)(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMELEV].CurValue);
			//LookFrom[2] = (float)((GeoCtrLat - Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLAT].CurValue) * EARTHLATSCALE_METERS);
			Master->RBounds.DefDegToRBounds(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLAT].CurValue, Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLON].CurValue, X, Y);
			LookFrom[0] = (float)((X - GeoCtrLon) * Master->ExportRefData.ExportLonScale);
			LookFrom[1] = (float)((Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMELEV].CurValue - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
			LookFrom[2] = (float)((GeoCtrLat - Y) * Master->ExportRefData.ExportLatScale);
			fprintf(fVRML, " position %f %f %f\n", LookFrom[0], LookFrom[1], LookFrom[2]);
			if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_UNTARGETED)
				{
				Orient[0] = -Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_PITCH].CurValue;
				Orient[1] = -Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_HEADING].CurValue;
				Orient[2] = Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_BANK].CurValue;
				} // if untargeted
			else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_TARGETED)
				{
				Orient[0] = -Cam->CamPitch;
				Orient[1] = -Cam->CamHeading;
				Orient[2] = Cam->CamBank;
				} // else if targeted
			else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_OVERHEAD)
				{
				Orient[0] = -Cam->CamPitch;
				Orient[1] = -Cam->CamHeading;
				Orient[2] = Cam->CamBank;
				} // else if overhead
			if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_ALIGNED)
				{
				Orient[0] = -Cam->CamPitch;
				Orient[1] = -Cam->CamHeading;
				Orient[2] = Cam->CamBank;
				} // if untargeted
			EulerToAxisAngle(Orient, AxisAngle);
			AxisAngle[3] *= PiOver180;
			fprintf(fVRML, " orientation %f %f %f %f\n", (float)AxisAngle[0], (float)-AxisAngle[1], (float)-AxisAngle[2], (float)AxisAngle[3]);
			fprintf(fVRML, " fieldOfView %f\n", (float)(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_HFOV].CurValue * PiOver180));
			fprintf(fVRML, " description \"%s\"\n}\n", Cam->Name);

			// extra stuff for animated cameras
			if (AnimCam)
				{
				float seconds;
				long LastKey, MaxKey, n;

				RendData.InitToView(EffectsHost, ProjectHost, DBHost, ProjectHost->Interactive, RJob->Options, Cam, 1024, 1024);

				// create timers
				LastKey = 0;
				MaxKey = -1;
				do
					{
					LastKey = RendData.Cam->GetNextMotionKeyFrame(LastKey, RendData.FrameRate);
					if (LastKey > MaxKey)
						MaxKey = LastKey;
					} while (LastKey >= 0);
				seconds = (float)(MaxKey / RendData.FrameRate);
				fprintf(fVRML, "\nDEF TIMER%d TimeSensor {\n cycleInterval %f\n loop TRUE\n}\n", AnimCams, seconds);

				// create position interpolator
				fprintf(fVRML, "\nDEF POSITINT%d PositionInterpolator {\n key [", AnimCams);
				// create the keys
				for (n = 0; n <= MaxKey; n++)
					{
					float tmp;

					tmp = (float)n / MaxKey;
					// print no more than 10 values per line
					if ((n % 10) == 0)
						fprintf(fVRML, "\n  %f", tmp);
					else
						fprintf(fVRML, " %f", tmp);
					} // for
				fprintf(fVRML, " ]\n");
				// create the keyValues
				fprintf(fVRML, " keyValue [");
				for (n = 0; n <= MaxKey; n++)
					{
					RendData.Cam->SetToTime(n / RendData.FrameRate);
					RendData.Cam->InitToRender(NULL, NULL);
					RendData.Cam->InitFrameToRender(GlobalApp->AppEffects, &RendData);
					// convert geographic position to meters & our repositioning
					// grh modified coords
					//LookFrom[0] = (float)((-Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLON].CurValue - GeoCtrLon) * EARTHLATSCALE_METERS);
					//LookFrom[1] = (float)(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMELEV].CurValue);
					//LookFrom[2] = (float)((GeoCtrLat - Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLAT].CurValue) * EARTHLATSCALE_METERS);
					Master->RBounds.DefDegToRBounds(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLAT].CurValue, Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLON].CurValue, X, Y);
					LookFrom[0] = (float)((X - GeoCtrLon) * Master->ExportRefData.ExportLonScale);
					LookFrom[1] = (float)((Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMELEV].CurValue - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
					LookFrom[2] = (float)((GeoCtrLat - Y) * Master->ExportRefData.ExportLatScale);
					// print no more than 3 triplets per line
					if ((n % 3) == 0)
						fprintf(fVRML, "\n  %f %f %f", LookFrom[0], LookFrom[1], LookFrom[2]);
					else
						fprintf(fVRML, ", %f %f %f", LookFrom[0], LookFrom[1], LookFrom[2]);
					} // for
				fprintf(fVRML, " ]\n}\n");

				// create orientation interpolator
				fprintf(fVRML, "\nDEF ORIENTINT%d OrientationInterpolator {\n key [", AnimCams);
				// create the keys
				for (n = 0; n <= MaxKey; n++)
					{
					float tmp;

					tmp = (float)n / MaxKey;
					// print no more than 10 values per line
					if ((n % 10) == 0)
						fprintf(fVRML, "\n  %f", tmp);
					else
						fprintf(fVRML, " %f", tmp);
					} // for
				fprintf(fVRML, " ]\n");
				// create the keyValues
				fprintf(fVRML, " keyValue [");
				for (n = 0; n <= MaxKey; n++)
					{
					if (RendData.Cam->TargetObj)
						RendData.Cam->TargetObj->SetToTime(n / RendData.FrameRate);
					RendData.Cam->SetToTime(n / RendData.FrameRate);
					RendData.Cam->InitToRender(NULL, NULL);
					RendData.Cam->InitFrameToRender(GlobalApp->AppEffects, &RendData);
					if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_UNTARGETED)
						{
						Orient[0] = -Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_PITCH].CurValue;
						Orient[1] = -Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_HEADING].CurValue;
						Orient[2] = Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_BANK].CurValue;
						} // if untargeted
					else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_TARGETED)
						{
						Orient[0] = -Cam->CamPitch;
						Orient[1] = -Cam->CamHeading;
						Orient[2] = Cam->CamBank;
						} // else if targeted
					else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_OVERHEAD)
						{
						Orient[0] = -Cam->CamPitch;
						Orient[1] = -Cam->CamHeading;
						Orient[2] = Cam->CamBank;
						} // else if overhead
					else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_ALIGNED)
						{
						Orient[0] = -Cam->CamPitch;
						Orient[1] = -Cam->CamHeading;
						Orient[2] = Cam->CamBank;
						} // else if aligned
					EulerToAxisAngle(Orient, AxisAngle);
					AxisAngle[3] *= PiOver180;
					// print no more than 3 values per line
					if ((n % 3) == 0)
						fprintf(fVRML, "\n  %f %f %f %f", (float)AxisAngle[0], (float)-AxisAngle[1], (float)-AxisAngle[2], (float)AxisAngle[3]);
					else
						fprintf(fVRML, ", %f %f %f %f", (float)AxisAngle[0], (float)-AxisAngle[1], (float)-AxisAngle[2], (float)AxisAngle[3]);
					} // for
				fprintf(fVRML, " ]\n}\n");

				AnimCams++;
				} // if AnimCam

			CamList = CamList->Next;
			} // while CamList
		} // if Cameras
	// a default overhead because VRML navigation is painful
	fprintf(fVRML, "\nViewpoint {\n");
	fprintf(fVRML, " position %f %f %f\n", 0.0f,
		(Master->ExportRefData.MaxElev + sx + sz - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale, 0.0f);
	fprintf(fVRML, " orientation 1 0 0 -1.570796\n");
	fprintf(fVRML, " description \"Top View\"\n}\n");

	// lights
	if (Master->ExportLights)
		{
		double X, Y;
		float tmp[3];
		class EffectList *LiteList = Master->Lights;
		class Light *Lite;

		while (LiteList)
			{
			Lite = (class Light *)LiteList->Me;
			if (Lite->Enabled)
				Illuminate3D = 1;	// if any enabled lights are exported, illuminate 3d objects
			switch (Lite->LightType)
				{
				default:
				case WCS_EFFECTS_LIGHTTYPE_PARALLEL:
					{
					tmp[0] = (float)Lite->Color.CurValue[0];
					tmp[1] = (float)Lite->Color.CurValue[1];
					tmp[2] = (float)Lite->Color.CurValue[2];
					fprintf(fVRML, "\nDirectionalLight {\n");
					fprintf(fVRML, " color %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					tmp[0] = (float)Lite->LightAim->XYZ[0];
					tmp[1] = (float)Lite->LightAim->XYZ[1];
					tmp[2] = (float)Lite->LightAim->XYZ[2];
					fprintf(fVRML, " direction %f %f %f\n", -tmp[0], tmp[1], tmp[2]);
					fprintf(fVRML, " ambientIntensity %f\n", 0.75f);
					tmp[0] = (float)min(1.0, Lite->Color.Intensity.CurValue);
					fprintf(fVRML, " intensity %f\n", tmp[0]);
					if (Lite->Enabled)
						fprintf(fVRML, " on TRUE\n}\n");
					else
						fprintf(fVRML, " on FALSE\n}\n");
					}
					break;
				case WCS_EFFECTS_LIGHTTYPE_OMNI:
					{
					fprintf(fVRML, "\nPointLight {\n");
					fprintf(fVRML, " attenuation 1 0 0\n");
					tmp[0] = (float)Lite->Color.CurValue[0];
					tmp[1] = (float)Lite->Color.CurValue[1];
					tmp[2] = (float)Lite->Color.CurValue[2];
					fprintf(fVRML, " color %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					tmp[0] = (float)min(1.0, Lite->Color.Intensity.CurValue);
					fprintf(fVRML, " intensity %f\n", tmp[0]);
					Master->RBounds.DefDegToRBounds(Lite->LightPos->Lat, Lite->LightPos->Lon, X, Y);
					tmp[0] = (float)((X - Master->ExportRefData.ExportRefLon) * Master->ExportRefData.ExportLonScale);
					tmp[1] = (float)((Lite->LightPos->Elev - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
					tmp[2] = (float)-((Y - Master->ExportRefData.ExportRefLat) * Master->ExportRefData.ExportLatScale);
					fprintf(fVRML, " location %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					if (Lite->Enabled)
						fprintf(fVRML, " on TRUE\n");
					else
						fprintf(fVRML, " on FALSE\n");
					tmp[0] = (float)min(500000, Lite->MaxIllumDist);
					fprintf(fVRML, " radius %f\n}\n", tmp[0]);
					}
					break;
				case WCS_EFFECTS_LIGHTTYPE_SPOT:
					{
					tmp[0] = (float)Lite->Color.CurValue[0];
					tmp[1] = (float)Lite->Color.CurValue[1];
					tmp[2] = (float)Lite->Color.CurValue[2];
					fprintf(fVRML, "\nSpotLight {\n");
					fprintf(fVRML, " attenuation 1 0 0\n");
					fprintf(fVRML, " beamWidth %f\n", (float)(Lite->AnimPar[WCS_EFFECTS_LIGHT_ANIMPAR_SPOTCONEEDGE].CurValue * PiOver180));
					fprintf(fVRML, " color %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					fprintf(fVRML, " cutOffAngle %f\n", (float)(Lite->AnimPar[WCS_EFFECTS_LIGHT_ANIMPAR_SPOTCONE].CurValue * PiOver180));
					tmp[0] = -(float)Lite->LightAim->XYZ[0];
					tmp[1] = (float)Lite->LightAim->XYZ[1];
					tmp[2] = (float)Lite->LightAim->XYZ[2];
					fprintf(fVRML, " direction %f %f %f\n", tmp[0], tmp[2], tmp[1]);
					tmp[0] = (float)min(1.0, Lite->Color.Intensity.CurValue);
					fprintf(fVRML, " intensity %f\n", tmp[0]);
					Master->RBounds.DefDegToRBounds(Lite->LightPos->Lat, Lite->LightPos->Lon, X, Y);
					tmp[0] = (float)((X - Master->ExportRefData.ExportRefLon) * Master->ExportRefData.ExportLonScale);
					tmp[1] = (float)((Lite->LightPos->Elev - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
					tmp[2] = (float)-((Y - Master->ExportRefData.ExportRefLat) * Master->ExportRefData.ExportLatScale);
					fprintf(fVRML, " location %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					if (Lite->Enabled)
						fprintf(fVRML, " on TRUE\n");
					else
						fprintf(fVRML, " on FALSE\n");
					fprintf(fVRML, " radius %f\n}\n", 100.0f); // (float)Lite->MaxIllumDist);
					}
					break;
				} // switch LightType
			LiteList = LiteList->Next;
			} // while LiteList
		} // if Lights
	else
		{
		fprintf(fVRML, "\nDirectionalLight {\n");
		fprintf(fVRML, " ambientIntensity 0.75\n direction 0.612372 -0.500000 0.612372\n}\n");
		} // else Lights

	// Fog
	if (Master->ExportHaze && Master->Haze)
		{
		class Atmosphere *Fog = (class Atmosphere *)Master->Haze->Me;

		if (Fog)
			{
			fprintf(fVRML, "\nFog\n{\n");
			fprintf(fVRML, " color %f %f %f\n", Fog->HazeColor.CurValue[0],  Fog->HazeColor.CurValue[1], Fog->HazeColor.CurValue[2]);
			// need sanity check on atmosphere type
			switch (Fog->AtmosphereType)
				{
				case WCS_EFFECTS_ATMOSPHERETYPE_SIMPLE:
					fprintf(fVRML, " fogType \"LINEAR\"\n");
					break;
				case WCS_EFFECTS_ATMOSPHERETYPE_EXPONENTIAL:
					fprintf(fVRML, " fogType \"EXPONENTIAL\"\n");
					break;
				default:
					// leaving the fogType field undefined will cause VRML to use the LINEAR default
					break;
				} // switch AtmosphereType
			fprintf(fVRML, " visibilityRange %f\n}\n", (float)Fog->HazeEndDistance);
			} // if Fog
		} // if Haze

	// the terrain
	if (Master->ExportTerrain)
		{
		MinTable = (float *)AppMem_Alloc(sizeof(float) * Master->DEMTilesX * Master->DEMTilesY, APPMEM_CLEAR);
		if (MinTable == NULL)
			{
			Success = 0;
			GlobalApp->StatusLog->PostError(WCS_LOG_SEVERITY_MSG, "VRML Export aborted - can't create MinTable!");
			goto Cleanup;
			} // if
		if (Tiles)
			{
			FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
			// scan tiles for min elev
			for (long ndx = 0, YTile = 0; YTile < Master->DEMTilesY; YTile++)
				{
				for (XTile = 0; XTile < Master->DEMTilesX; XTile++, ndx++)
					{
					MinTable[ndx] = MinElev(fRaw, tilesizex, tilesizey);
					fclose(fRaw);
					RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
					fRaw = PROJ_fopen(RawTerrainFile, "rb");
					} // for XTile
				} // for YTile
			// reset back to the first tile
			RawTerrainFile = NULL;
			RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
			fRaw = PROJ_fopen(RawTerrainFile, "rb");
			} // if Tiles
		else
			{
			MinTable[0] = MinElev(fRaw, tilesizex, tilesizey);
			} // else Tiles
		for (YTile = 0; YTile < Master->DEMTilesY; YTile++)
			{
			for (XTile = 0; XTile < Master->DEMTilesX; XTile++)
				{
				const char *OutputFilePath;
				float lod_xspace, lod_zspace, xdist, zdist;
				long lod_tilesizex, lod_tilesizey;
				long i, LODctr, qwik;
				char indent[8];

				xlate = -cx + sx / Master->DEMTilesX * XTile;
				ylate = 0.0f;
				zlate = -cz + sz / Master->DEMTilesY * YTile;
				fprintf(fVRML, "\nGroup {\n children [\n  Transform {\n   translation %f %f %f\n   children [\n",
					xlate, ylate, zlate);
				lod_tilesizex = tilesizex;
				lod_tilesizey = tilesizey;
				lod_xspace = xspace;
				lod_zspace = zspace;
				xdist = (tilesizex - 1) * xspace;
				zdist = (tilesizey - 1) * zspace;
				LODctr = Master->LODLevels;
					{
					double dist, step = Master->AnimPar[WCS_EFFECTS_SCENEEXPORTER_ANIMPAR_LODDISTBETWEEN].CurValue;
					float avg_elev;

					avg_elev = AvgElev(fRaw, tilesizex, tilesizey);
					fprintf(fVRML, "    LOD {\n     center %f %f %f\n     range [",
						(tilesizex - 1) * xspace / 2.0f, avg_elev, (tilesizey - 1) * zspace / 2.0f);	// center LOD calc on X & Z centers, avg elev
					dist = step;
					for (i = 1; i < LODctr; i++, dist += step)
						fprintf(fVRML, " %f", dist);
					fprintf(fVRML, " %f ]\n     level [\n", Master->AnimPar[WCS_EFFECTS_SCENEEXPORTER_ANIMPAR_LODDISTVANISH].CurValue);
					strcpy(indent, "  ");
					}
				i = LODctr;
				OutputFilePath = Master->OutPath.GetPath();
				do
					{
					float FlapElev = 0.0f;
					long flaps_x, flaps_y;

					EmitFlags = EmitFlaps = 0;
					flaps_x = flaps_y = 0;
					if (Master->LODFillGaps && (Master->LODLevels != 1))	// add flaps if told to & if we have multiple LOD's
						{
						float dx, dz;

						if (XTile != 0)
							{
							EmitFlags |= FLAPFLAG_EMIT_W;
							flaps_x++;
							} // if
						if (XTile != (Master->DEMTilesX - 1))
							{
							EmitFlags |= FLAPFLAG_EMIT_E;
							flaps_x++;
							} // if
						if (YTile != 0)
							{
							EmitFlags |= FLAPFLAG_EMIT_N;
							flaps_y++;
							} // if
						if (YTile != (Master->DEMTilesY - 1))
							{
							EmitFlags |= FLAPFLAG_EMIT_S;
							flaps_y++;
							} // if
						if (EmitFlags)
							EmitFlaps = 1;
						// translate this tile into correct alignment since we're adding flaps
						dx = dz = 0.0f;
						if (EmitFlags & FLAPFLAG_EMIT_W)
							dx = (float)-lod_xspace;
						if (EmitFlags & FLAPFLAG_EMIT_N)
							dz = (float)-lod_zspace;
						fprintf(fVRML, "Group {\n children [\n  Transform {\n   translation %f 0.0 %f\n   children [\n", dx, dz);
						} // if LODCtr != 1
					fprintf(fVRML, "%s    Shape {\n", indent);
					if (Master->ExportTexture)
						{
						float xlate, xscale, zlate, zscale;

						fprintf(fVRML, "%s     appearance Appearance {\n", indent);
						fprintf(fVRML, "%s      textureTransform TextureTransform {\n", indent);
						xscale =  (lod_tilesizex + flaps_x) / (float)lod_tilesizex;
						zscale =  -(lod_tilesizey + flaps_y) / (float)lod_tilesizey;
						if (EmitFlags & FLAPFLAG_EMIT_W)
							xlate = -1.0f / (lod_tilesizex + flaps_x);
						else
							xlate = 0.0f;
						// align the t origin with the tiles natural (non-flap) border
						if (!(EmitFlags & FLAPFLAG_EMIT_S))	// ie: we're in the last row
							zlate = -1.0f;
						else
							zlate = -(lod_tilesizey + flaps_y - 1.0f) / (lod_tilesizey + flaps_y);
						fprintf(fVRML, "%s       translation %f %f\n%s       scale %f %f\n%s      }\n",
							indent, xlate, zlate, indent, xscale, zscale, indent);
						/***
						fprintf(fVRML, "%s      material Material {\n", indent);
						fprintf(fVRML, "%s       ambientIntensity 0.45\n", indent);
						fprintf(fVRML, "%s       diffuseColor 1.0 1.0 1.0\n", indent);
						fprintf(fVRML, "%s      }\n", indent);
						***/
						fprintf(fVRML, "%s      texture ImageTexture {\n", indent);
						fprintf(fVRML, "%s       url \"%s\"\n", indent, TextureFile);
						fprintf(fVRML, "%s       repeatS FALSE\n%s       repeatT FALSE\n%s      }\n%s     }\n", indent, indent, indent, indent);
						} // if
					fprintf(fVRML, "%s     geometry ElevationGrid {\n", indent);
					fprintf(fVRML, "%s      solid FALSE\n", indent);
					fprintf(fVRML, "%s      xDimension %d\n", indent, lod_tilesizex + flaps_x);
					fprintf(fVRML, "%s      zDimension %d\n", indent, lod_tilesizey + flaps_y);
					fprintf(fVRML, "%s      xSpacing %f\n", indent, lod_xspace);
					fprintf(fVRML, "%s      zSpacing %f\n", indent, lod_zspace);
					fprintf(fVRML, "%s      height [\n", indent);

					if (Tiles && EmitFlaps)
						{
						long last_ndx = Master->DEMTilesX * Master->DEMTilesY;

						FlapElev = FLT_MAX;
						if (EmitFlags & FLAPFLAG_EMIT_N)
							{
							qwik = (YTile - 1) * Master->DEMTilesX + XTile - 1;	// NW cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik++;	// N cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik++; // NE cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							} // if EmitFlags & FLAPFLAG_EMIT_N
						if (EmitFlags & FLAPFLAG_EMIT_S)
							{
							qwik = (YTile + 1) * Master->DEMTilesX + XTile - 1;	// SW cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik++;	// S cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik++; // SE cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							} // if EmitFlags & FLAPFLAG_EMIT_S
						if (EmitFlags & FLAPFLAG_EMIT_E)
							{
							qwik = (YTile - 1) * Master->DEMTilesX + XTile + 1;	// NE cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik += Master->DEMTilesX;	// E cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik += Master->DEMTilesX;	// SE cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							} // if EmitFlags & FLAPFLAG_EMIT_E
						if (EmitFlags & FLAPFLAG_EMIT_W)
							{
							qwik = (YTile - 1) * Master->DEMTilesX + XTile - 1;	// NW cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik += Master->DEMTilesX;	// W cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							qwik += Master->DEMTilesX;	// SW cell
							if ((qwik >= 0) && (qwik < last_ndx) && (MinTable[qwik] < FlapElev))
								FlapElev = MinTable[qwik];
							} // if EmitFlags & FLAPFLAG_EMIT_W
						FlapElev += ElevAdjust;
						} // if Tiles
					// "Automatically" save the elev model
					TW->EmitTerrain(lod_tilesizex, lod_tilesizey, fRaw, fVRML, ElevAdjust, FlapElev, EmitFlaps, EmitFlags);
					rewind(fRaw);

					fprintf(fVRML, "\n%s      ]\n", indent);
					/***
					// workaround for Z Corporations ZPrint bug
					fprintf(fVRML, "     texCoord TextureCoordinate {\n      point [\n");
					for (long t = 0; t < lod_tilesizey; t++)
						{
						for (long s = 0; s < lod_tilesizex; s++)
							{
							static long pairs = 0;
							fprintf(fVRML, "      %f %f", s / (float)(lod_tilesizex - 1), t / (float)(lod_tilesizey - 1));
							pairs++;
							if ((pairs % 8) == 0)
								fprintf(fVRML, "\n");
							} // for s
						} // for t
					fprintf(fVRML, "\n      ]\n     }\n");
					fprintf(fVRML, "    }\n # Yo!\n");
					***/
					fprintf(fVRML, "%s     }\n%s    } # End Shape\n", indent, indent);
					if (Master->LODFillGaps && (Master->LODLevels != 1))
						{
						// end tile translation block
						fprintf(fVRML, "   ]\n  }\n ]\n}\n");
						} // if

					// create new LOD if needed
					if (i != 0)
						{
						RasterResampler *Resamp = NULL;
						char ResampledFile[512];

						if (!(Resamp = new FloatRasterResampler()))
							break;	// quietly fail LOD
						Resamp->SetNull(-9999.0f);

						strmfp(ResampledFile, Master->OutPath.Path, "lod_tmp.raw");
						lod_tilesizex /= 2;
						lod_tilesizey /= 2;
						if (lod_tilesizex < 2)
							lod_tilesizex = 2;
						//Master->DEMResX = lod_tilesizex;
						if (lod_tilesizey < 2)
							lod_tilesizey = 2;
						//Master->DEMResY = lod_tilesizey;
						lod_xspace = xdist / (lod_tilesizex - 1);
						lod_zspace = zdist / (lod_tilesizey - 1);
						fclose(fRaw);
						if (Tiles)
							{
							if (Resamp->Resample(RawTerrainFile, ResampledFile,
								Master->OneDEMResY, Master->OneDEMResX, lod_tilesizey, lod_tilesizex))
							//if (Resamp->ResampleTile(RawTerrainFile, ResampledFile, Master->OneDEMResY, Master->OneDEMResX,
							//	lod_tilesizey, lod_tilesizex, Master->DEMTilesY, Master->DEMTilesX, YTile, XTile, Master->DEMTileOverlap))
								{
								// reset RasterBounds
								Master->RBounds.DeriveTileCoords(Master->DEMResY, Master->DEMResX, 
									Master->DEMTilesY, Master->DEMTilesX, YTile, XTile, Master->DEMTileOverlap);
								fRaw = PROJ_fopen(ResampledFile, "rb");
								} // if
							//else
								//UserMessageOK(RawTerrainFile, "Error tiling this file. Export terminated.");
							} // if Tiles
						else
							{
							if (Resamp->Resample(RawTerrainFile, ResampledFile,
								Master->DEMResY, Master->DEMResX, lod_tilesizey, lod_tilesizex))
								{
								// reset RasterBounds
								Master->RBounds.DeriveCoords(Master->DEMResY, Master->DEMResX);
								fRaw = PROJ_fopen(ResampledFile, "rb");
								} // if
							//else
								//UserMessageOK(RawTerrainFile, "Error resampling this file. Export terminated.");
							} // else Tiles
						delete Resamp;
						Resamp = NULL;
						} // if i
					i--;
					} while (i >= 1);
				fprintf(fVRML, "      Shape {} # Vanish node\n");
				fprintf(fVRML, "     ]\n    } # End LOD\n");

				if (fRaw)
					{
					fclose(fRaw);
					fRaw = NULL;
					} // if

				if (Tiles)
					{
					FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
					RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
					fRaw = PROJ_fopen(RawTerrainFile, "rb");

					FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
					TextureFile = (*FileNamesCreated)->FindNextNameOfType(FileType, TextureFile);
					} // if tiles

				fprintf(fVRML, "   ]\n  }\n ]\n}\n");	// close Group
				} // for XTile
			} // for YTile
		} // if Master->ExportTerrain

	if (fRaw)
		{
		fclose(fRaw);
		fRaw = NULL;
		} // if

	if (Master->ExportFoliage)
		{
		FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
		if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
			{
			FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
			if (DataFileName = (*FileNamesCreated)->FindNameOfType(FileType))
				{
				//double TexRefLat, TexRefLon, TexRefElev, TexDeltaLat, TexDeltaLon;
				// you've got the two file names that the Renderer wrote out.
				// combine them with the output file path to make a file that can be opened with PROJ_fopen()

				// find and open the index file
				strmfp(FileName, OutputFilePath, IndexFileName);
				if (ffile = PROJ_fopen(FileName, "rb"))
					{
					// read file descriptor, no need to keep it around unless you want to
					fgets(FileName, 256, ffile);
					// version
					fread((char *)&Index.FileVersion, sizeof (char), 1, ffile);
					// number of files
					fread((char *)&Index.NumCells, sizeof (long), 1, ffile);
					// reference XYZ
					fread((char *)&Index.RefXYZ[0], sizeof (double), 1, ffile);
					fread((char *)&Index.RefXYZ[1], sizeof (double), 1, ffile);
					fread((char *)&Index.RefXYZ[2], sizeof (double), 1, ffile);

					if (Index.NumCells > 0)
						{
						// only one cell data entry is provided
						if (Index.CellDat = &RFCD)
							{
							// file name
							fgets(Index.CellDat->FileName, 64, ffile);
							// center XYZ
							fread((char *)&Index.CellDat->CellXYZ[0], sizeof (double), 1, ffile);
							fread((char *)&Index.CellDat->CellXYZ[1], sizeof (double), 1, ffile);
							fread((char *)&Index.CellDat->CellXYZ[2], sizeof (double), 1, ffile);
							// half cube cell dimension
							fread((char *)&Index.CellDat->CellRad, sizeof (double), 1, ffile);
							// number of trees in file
							fread((char *)&Index.CellDat->DatCt, sizeof (long), 1, ffile);
							} // if
						} // if some cells to read
					fclose(ffile);

					if((Index.NumCells > 0) && (Index.CellDat->DatCt > 0))
						{
						strmfp(FileName, OutputFilePath, DataFileName);
						if (ffile = PROJ_fopen(FileName, "rb"))
							{
							Raster *CurRast, *RastLoop;
							long n;

							for (n = 1, RastLoop = Images->GetFirstRast(); RastLoop; RastLoop = Images->GetNextRast(RastLoop), n++)
								{
								char ImageName[256];

								if (CurRast = Images->FindByID(n))
									{
									strcpy(ImageName, CurRast->GetUserName());
									ImageSaverLibrary::StripImageExtension(ImageName);
									strcat(ImageName, "_Fol");
									ReplaceChar(ImageName, '.', '_');
									strcat(ImageName, ImageSaverLibrary::GetDefaultExtension(Master->FoliageImageFormat));
									FileType = WCS_EXPORTCONTROL_FILETYPE_FOLIAGETEX;
									if ((*FileNamesCreated)->FindNameExists(FileType, ImageName))
										{
										// indeed a resampled image has been created for this entry
										// so it is safe to add this entry into the foliage definitions
										fprintf(fVRML, "\nDEF Foliage%d Transform {\n children [\n  Shape {\n", n);
										fprintf(fVRML, "   appearance Appearance {\n    texture ImageTexture {\n");
										strcpy(ImageName, RastLoop->GetUserName());
										ImageSaverLibrary::StripImageExtension(ImageName);
										strcat(ImageName, "_Fol");
										ReplaceChar(ImageName, '.', '_');
										strcat(ImageName, ImageSaverLibrary::GetDefaultExtension(Master->FoliageImageFormat));
										fprintf(fVRML, "     url \"%s\"\n     repeatS FALSE\n     repeatT FALSE\n    }\n   }\n", ImageName);
										// create a square face 1 meter large, and centered at coords (0m 0m 0m)
										fprintf(fVRML, "   geometry IndexedFaceSet {\n    coord Coordinate {\n     point [");
										fprintf(fVRML, " -0.5 -0.5 0.0, 0.5 -0.5 0.0, 0.5 0.5 0.0, -0.5 0.5 0.0 ]\n");
										fprintf(fVRML, "    }\n    coordIndex [");
										fprintf(fVRML, " 0 1 2 -1, 2 3 0 -1 ]\n    solid FALSE\n");
										fprintf(fVRML, "   }\n  }\n ]\n}\n");
										} // if
									} // if
								} // for

							//TexRefLon = Index.RefXYZ[0];
							//TexRefLat = Index.RefXYZ[1];
							//TexRefElev = Index.RefXYZ[2];
							//TexDeltaLon = GeoCtrLon - TexRefLon;
							//TexDeltaLat = GeoCtrLat - TexRefLat;

							fgets(FileName, 64, ffile);
							// version
							fread((char *)&TestFileVersion, sizeof (char), 1, ffile);
							// Pointless version check -- we know we wrote it
							if (TestFileVersion == Index.FileVersion)
								{
								for (DatPt = 0; DatPt < Index.CellDat->DatCt; DatPt ++)
									{
									if (FolData.ReadFoliageRecord(ffile, Index.FileVersion))
										{
										if (FolData.InterpretFoliageRecord(NULL, Images, &PointData)) // don't need full decoding of 3dobjects, just height, etc
											{
											float x, y, z;

											fprintf(fVRML, "\nTransform {\n");
											// Lat & Lon are in geographic relative to the TexRef coords: convert to meters & reposition
											// grh modifed coords, now they are in the export coord sys with positive always to east even if geographic
											//x = (float)(((-FolData.XYZ[0] + TexRefLon) - GeoCtrLon) * EARTHLATSCALE_METERS * LonScale);
											//y = (float)(FolData.XYZ[2] + TexRefElev + (PointData.Height / 2.0));
											//z = (float)((GeoCtrLat - (FolData.XYZ[1] + TexRefLat)) * EARTHLATSCALE_METERS);
											x = (float)(FolData.XYZ[0] * Master->ExportRefData.ExportLonScale);
											y = (float)(FolData.XYZ[2] * Master->ExportRefData.ElevScale + (PointData.Height / 2.0));
											z = (float)(-FolData.XYZ[1] * Master->ExportRefData.ExportLatScale);
											fprintf(fVRML, " translation %f %f %f\n children [\n  Billboard {\n   children [\n", x, y, z);
											x = (float)PointData.Width;
											y = (float)PointData.Height;
											z = 1.0f;
											fprintf(fVRML, "    Transform {\n     scale %f %f %f\n", x, y, z);
											if (PointData.FlipX)
												fprintf(fVRML, "     rotation 0 1 0 3.14159\n");
											/***
											if (FolData.ElementID < 0)
												{
												UserMessageOK("Yikes!", "Encountered a Negative Foliage ElementID");
												fprintf(fVRML, "     children USE Foliage%d # Yikes\n    }\n   ]\n  }\n ]\n}\n", -FolData.ElementID);
												}
											else
												fprintf(fVRML, "     children USE Foliage%d\n    }\n   ]\n  }\n ]\n}\n", FolData.ElementID);
											***/
											fprintf(fVRML, "     children USE Foliage%d\n    }\n   ]\n  }\n ]\n}\n", FolData.ElementID);
											} // if
										} // if
									} // for
								// must do this as it's not dynamically allocated and RealtimeFoliageIndex
								// destructor will blow chunks if we don't
								Index.CellDat = NULL;
								} // if
							fclose(ffile);
							} // if
						} // if
					} // if ffile
				} // if DataFileName
			} // if IndexFileName
		} // if ExportFoliage

	// Now process any 3D objects we find
	if (Master->ObjectInstanceList)
	//if (Master->Export3DObjects || Master->ExportWalls || Master->Export3DFoliage)
		{
		//MaterialEffect *Mat;
		Object3DInstance *ObjectList = Master->ObjectInstanceList;
		Object3DEffect *Object3D;
		//ObjectMaterialEntry *NameTable;
		ObjectPerVertexMap *UVMap = NULL;
		float boxx, boxy, boxz, /* boxctr[3],*/ dx, dy, dz;
		double geo[3], /* rot[3], */ scale[3], x, y, z; /*, trans[3];*/
		long DidCoords, MatCt, PolyCt, VertCt;

		while (ObjectList)
			{
			Point4d AxisAngle;
			long i, WallObject;

			DidCoords = 0;
			Object3D = ObjectList->MyObj;
			if (!((Object3D->Vertices && Object3D->Polygons && Object3D->NameTable) || Object3D->OpenInputFile(NULL, FALSE, FALSE, FALSE)))
				goto SkipObject;
			boxx = (float)(Object3D->ObjectBounds[0] - Object3D->ObjectBounds[1]);
			//boxctr[0] = (float)((o3di->MyObj->ObjectBounds[0] + o3di->MyObj->ObjectBounds[1]) / 2.0);
			boxy = (float)(Object3D->ObjectBounds[2] - Object3D->ObjectBounds[3]);
			//boxctr[1] = (float)((o3di->MyObj->ObjectBounds[2] + o3di->MyObj->ObjectBounds[3]) / 2.0);
			boxz = (float)(Object3D->ObjectBounds[4] - Object3D->ObjectBounds[5]);
			//boxctr[2] = (float)((o3di->MyObj->ObjectBounds[4] - o3di->MyObj->ObjectBounds[5]) / 2.0);
			for (i = 0; i < 3; i++)
				{
				// grh modified coords
				//geo[i] = ObjectList->Geographic[i];
				geo[i] = ObjectList->ExportXYZ[i];
				//rot[i] = ObjectList->Euler[i];
				scale[i] = ObjectList->Scale[i];
				//trans[i] = (float)o3di->Translation[i];
				} // for
			// convert geographic position to meters & our repositioning
			// grh modified coords
			//dx = (float)((-geo[0] - GeoCtrLon) * EARTHLATSCALE_METERS * LonScale);
			dx = (float)(geo[0] * Master->ExportRefData.ExportLonScale);
			//dy = (float)(geo[2] + boxy / 2.0);
			dy = (float)geo[2];
			dz = (float)(-geo[1] * Master->ExportRefData.ExportLatScale);
			fprintf(fVRML, "\n# %s\n", Object3D->Name);
			WallObject = 0;
			if (strncmp(Object3D->Name, "WO0", 3) == 0)
				WallObject = 1;
			fprintf(fVRML, "Transform {\n");
			QuaternionToAxisAngle(AxisAngle, ObjectList->Quaternion);
			AxisAngle[3] *= PiOver180;
			fprintf(fVRML, " rotation %f %f %f %f\n", AxisAngle[0], -AxisAngle[1], AxisAngle[2], -AxisAngle[3]);
			/***
			// negation of rotation terms switches from left handed to right handed notation
			if (rot[2] != 0.0f)
				fprintf(fVRML, " rotation 0.0 0.0 1.0 %f\n", -rot[2]);	// bank    = z-axis
			if (rot[0] != 0.0f)
				fprintf(fVRML, " rotation 1.0 0.0 0.0 %f\n", -rot[0]);	// pitch   = x-axis
			if (rot[1] != 0.0f)
				fprintf(fVRML, " rotation 0.0 1.0 0.0 %f\n", -rot[1]);	// heading = y-axis
			***/
			if ((scale[0] != 1.0f) && (scale[1] != 1.0f) && (scale[2] != 1.0f))
				fprintf(fVRML, " scale %f %f %f\n", scale[0], scale[1], scale[2]);
			fprintf(fVRML, " translation %f %f %f\n", dx, dy, dz);
			fprintf(fVRML, " children [\n");
			MatCt = 0;
			fprintf(fVRML, "  LOD {\n   range [ %f %f ]\n   level [\n    Group {\n     children [\n",
				Master->AnimPar[WCS_EFFECTS_SCENEEXPORTER_ANIMPAR_OBJECTDISTBOX].CurValue,
				Master->AnimPar[WCS_EFFECTS_SCENEEXPORTER_ANIMPAR_OBJECTDISTVANISH].CurValue);
			do
				{
				fprintf(fVRML, "      # %s\n", Object3D->NameTable[MatCt].Name);
				fprintf(fVRML, "      Shape {\n");
				fprintf(fVRML, "       appearance Appearance {\n");
				ProcessMatTexture(MatCt, fVRML, Object3D);
				UVMap = NULL;
				if (Object3D->VertexUVWAvailable)
					{
					UVMap = &Object3D->UVWTable[0];
					if (Illuminate3D)
						{
						fprintf(fVRML, "        material Material {\n");
						fprintf(fVRML, "         diffuseColor 1.0 1.0 1.0\n");
						fprintf(fVRML, "         specularColor 1.0 1.0 1.0\n");
						fprintf(fVRML, "        }\n");
						} // if
					} // if
				else
					{
					float ambient;
					
					ambient = (float)(Object3D->NameTable[MatCt].Mat->AnimPar[WCS_EFFECTS_MATERIAL_ANIMPAR_LUMINOSITY].CurValue * 1.8);
					if (ambient < 0.0f)
						ambient = 0.0f;
					else if (ambient > 1.0f)
						ambient = 1.0f;
					fprintf(fVRML, "        material Material {\n");
					if (ambient > 0.0)
						fprintf(fVRML, "         ambientIntensity %f\n", ambient);
					fprintf(fVRML, "         diffuseColor %f %f %f\n", (float)Object3D->NameTable[MatCt].Mat->DiffuseColor.CurValue[0],
						(float)Object3D->NameTable[MatCt].Mat->DiffuseColor.CurValue[1], (float)Object3D->NameTable[MatCt].Mat->DiffuseColor.CurValue[2]);
					fprintf(fVRML, "         specularColor %f %f %f\n", (float)Object3D->NameTable[MatCt].Mat->SpecularColor.CurValue[0],
						(float)Object3D->NameTable[MatCt].Mat->SpecularColor.CurValue[1], (float)Object3D->NameTable[MatCt].Mat->SpecularColor.CurValue[2]);
					fprintf(fVRML, "        }\n");
					} // else
				fprintf(fVRML, "       }\n");
				//fprintf(fVRML, "   geometry Box\n   {\n    size %f %f %f\n", boxx, boxy, boxz);

				if (DidCoords)
					fprintf(fVRML, "       geometry IndexedFaceSet {\n        coord USE COORD%d\n", CoordsCount);
				else
					{
					DidCoords = 1;
					CoordsCount++;
					fprintf(fVRML, "       geometry IndexedFaceSet {\n        coord DEF COORD%d Coordinate {\n         point [\n", CoordsCount);
					for (VertCt = 0; VertCt < Object3D->NumVertices; VertCt++)
						{
						if ((VertCt % 5) != 0)
							fprintf(fVRML, ", ");
						// VtxData is an array of x,y,z triplets, careful of order
						x = Object3D->Vertices[VertCt].xyz[0];
						y = Object3D->Vertices[VertCt].xyz[1];
						z = Object3D->Vertices[VertCt].xyz[2];
						fprintf(fVRML, "%f %f %f", (float)(x), (float)(y), (float)(-z));
						if ((VertCt % 5) == 4)
							fprintf(fVRML, "\n");
						} // for VertCt
					fprintf(fVRML, "\n         ]\n        }\n");
					} // else
				fprintf(fVRML, "        coordIndex [\n");
				for (PolyCt = 0; PolyCt < Object3D->NumPolys; PolyCt++)
					{
					if (Object3D->Polygons[PolyCt].Material == MatCt)
						{
						fprintf(fVRML, "         ");
						for (long i = 0; i < Object3D->Polygons[PolyCt].NumVerts; i++)
							fprintf(fVRML, "%d ", Object3D->Polygons[PolyCt].VertRef[i]);
						fprintf(fVRML, "-1\n");
						} // if
					} // for PolyCt
				fprintf(fVRML, "        ]\n");
				if (UVMap)
					{
					float u, v;
					fprintf(fVRML, "        texCoord TextureCoordinate {\n     point [\n");
					for (VertCt = 0; VertCt < Object3D->NumVertices; VertCt++)
						{
						if (UVMap->CoordsValid[VertCt])
							{
							u = UVMap->CoordsArray[0][VertCt];
							v = UVMap->CoordsArray[1][VertCt];
							} // if CoordsValid
						else
							u = v = 0.0f;
						fprintf(fVRML, "          %f %f\n", u, v);
						} // for VertCt
					fprintf(fVRML, "         ]\n        }\n");
					} // if UVMap
				if (WallObject)
					fprintf(fVRML, "        ccw   FALSE\n");
				fprintf(fVRML, "        solid FALSE\n       }\n      } # End: %s\n", Object3D->NameTable[MatCt].Name);
				MatCt++;
				} while (MatCt < Object3D->NumMaterials);
			fprintf(fVRML, "     ]\n    }\n");
			fprintf(fVRML, "    # Box node\n");
			fprintf(fVRML, "    Group {\n     children [\n      Transform {\n       translation 0.0 %f 0.0\n", boxy / 2.0f);
			fprintf(fVRML, "       children [\n");
			fprintf(fVRML, "        Shape {\n");
			fprintf(fVRML, "         appearance Appearance {\n");
			fprintf(fVRML, "          material Material {\n");
			fprintf(fVRML, "           diffuseColor %f %f %f\n", (float)Object3D->NameTable[0].Mat->DiffuseColor.CurValue[0],
				(float)Object3D->NameTable[0].Mat->DiffuseColor.CurValue[1], (float)Object3D->NameTable[0].Mat->DiffuseColor.CurValue[2]);
			fprintf(fVRML, "           specularColor %f %f %f\n", (float)Object3D->NameTable[0].Mat->SpecularColor.CurValue[0],
				(float)Object3D->NameTable[0].Mat->SpecularColor.CurValue[1], (float)Object3D->NameTable[0].Mat->SpecularColor.CurValue[2]);
			fprintf(fVRML, "          }\n");
			fprintf(fVRML, "         }\n");
			fprintf(fVRML, "         geometry Box { size %f %f %f } } ] } ] }\n", boxx, boxy, boxz);
			fprintf(fVRML, "    # Vanish node\n");
			fprintf(fVRML, "    Group { children [ ] }\n");
			fprintf(fVRML, "   ]\n  } # End LOD\n");
			fprintf(fVRML, " ]\n} # End: %s\n", Object3D->Name);

SkipObject:
			ObjectList = ObjectList->Next;
			} // while ObjectList
		} // if 3D objects

	// Vectors
	if (Master->ExportVectors && Master->VecInstanceList)
		{
		double vLat, vLon;
		float vElev;
		long i, n;
		Joe *CurJoe;
		VectorExportItem *VEI;
		VectorPoint *vert;

		for (n = 0; n < Master->NumVecInstances; n++)
			{
			VEI = &Master->VecInstanceList[n];
			CurJoe = VEI->MyJoe;
			// start the shape & set the color
			fprintf(fVRML, "\nShape {\n appearance Appearance {\n  material Material {\n");
			fprintf(fVRML, "   diffuseColor %f %f %f\n", CurJoe->Red() / 255.0f, CurJoe->Green() / 255.0f, CurJoe->Blue() / 255.0f);
			fprintf(fVRML, "  }\n }\n");
			// now the geometry
			fprintf(fVRML, " geometry IndexedLineSet {\n  coord Coordinate {\n   point [");
			vert = VEI->Points;
			i = 0;
			while (vert)
				{
				vLat = vert->Latitude * Master->ExportRefData.ExportLatScale;
				vLon = vert->Longitude * Master->ExportRefData.ExportLonScale;
				vElev = vert->Elevation;
				// print no more than 4 triplets per line
				if ((i % 4) == 0)
					fprintf(fVRML, "\n    %f %f %f", (float)vLon, vElev, -(float)vLat);
				else
					fprintf(fVRML, ", %f %f %f", (float)vLon, vElev, -(float)vLat);
				i++;
				vert = vert->Next;
				} // while vert
			fprintf(fVRML, "\n   ]\n  }\n");
			fprintf(fVRML, "  coordIndex [\n   ");
			for (i = 0; i < VEI->NumPoints; i++)
				fprintf(fVRML, "%d ", i);
			fprintf(fVRML, "\n  ]\n }\n}\n");
			} // while VEI

		} // if Vectors

	// Do timer routing if we had any animated cameras
	if (AnimCams)
		{
		long n;

		// route timer events to interpolators
		for (n = 0; n < AnimCams; n++)
			{
			fprintf(fVRML, "\nROUTE TIMER%d.fraction_changed TO POSITINT%d.set_fraction\n", n, n);
			fprintf(fVRML, "ROUTE TIMER%d.fraction_changed TO ORIENTINT%d.set_fraction\n", n, n);
			} // for

		// route interpolators to viewpoints
		for (n = 0; n < AnimCams; n++)
			{
			fprintf(fVRML, "\nROUTE POSITINT%d.value_changed TO ANIMCAM%d.position\n", n, n);
			fprintf(fVRML, "ROUTE ORIENTINT%d.value_changed TO ANIMCAM%d.orientation\n", n, n);
			} // for

		} // if AnimCams

	if (Master->ZipItUp)
		{
		gzFile gz;
		size_t bytes;
		char buffer[1024];

		if (X3D)
			SceneOutput.GetFramePathAndName(TempFullPath, ".x3dvz", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		else
			SceneOutput.GetFramePathAndName(TempFullPath, ".wrz", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		strcpy(TempFullPath, GlobalApp->MainProj->MungPath(TempFullPath));
		if (gz = gzopen(TempFullPath, "wb9"))
			{
			rewind(fVRML);

			while (bytes = fread(buffer, 1, 1024, fVRML))
				gzwrite(gz, buffer, (unsigned int)bytes);

			if (gzclose(gz) == Z_OK)	// remove the original file if compression was successful
				{
				fclose(fVRML);
				SceneOutput.GetFramePathAndName(TempFullPath, ".wrl", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
				strcpy(TempFullPath, GlobalApp->MainProj->MungPath(TempFullPath));
				remove(TempFullPath);
				} // if Z_OK
			} // if gz
		} // if gzipping

	} // if
else
	Success = 0;

Cleanup:

if (Master->ExportFoliage)
	{
	// remove foliage temp files
	FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
	if (CleanFileName = (*FileNamesCreated)->FindNameOfType(FileType))
		{
		strmfp(FullFileName, OutputFilePath, CleanFileName);
		PROJ_remove(FullFileName);

		FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
		if (CleanFileName = (*FileNamesCreated)->FindNameOfType(FileType))
			{
			strmfp(FullFileName, OutputFilePath, CleanFileName);
			PROJ_remove(FullFileName);
			} // if
		} // if
	} // if

if (Master->ExportTerrain)
	{
	// remove terrain temp file(s)
	FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	if (Tiles)
		{
		CleanFileName = NULL;
		CleanFileName = (*FileNamesCreated)->FindNextNameOfType(FileType, CleanFileName);
		while (CleanFileName)
			{
			strmfp(FullFileName, OutputFilePath, CleanFileName);
			PROJ_remove(FullFileName);
			CleanFileName = (*FileNamesCreated)->FindNextNameOfType(FileType, CleanFileName);
			} // while
		} // if Tiles
	else
		{
		CleanFileName = (*FileNamesCreated)->FindNameOfType(FileType);
		strmfp(FullFileName, OutputFilePath, CleanFileName);
		PROJ_remove(FullFileName);
		} // else Tiles

	// remove resampled file
	strmfp(FullFileName, OutputFilePath, "lod_tmp.raw");
	PROJ_remove(FullFileName);
	} // if

if (MinTable)
	{
	AppMem_Free(MinTable, Master->DEMTilesX * Master->DEMTilesY * sizeof(float));
	MinTable = NULL;
	} // if

if (TW)
	{
	delete TW;
	TW = NULL;
	} // if

if (fVRML)
	{
	fclose(fVRML);
	fVRML = NULL;
	} // if

if (fRaw)
	{
	fclose(fRaw);
	fRaw = NULL;
	} // if

if (RJob)
	{
	delete RJob;
	RJob = NULL;
	} // if

// must do this as it's not dynamically allocated and RealtimeFoliageIndex
// destructor will blow chunks if we don't
Index.CellDat = NULL;

return (Success);

} // ExportFormatVRML::PackageExport

/*===========================================================================*/

int ExportFormatVRML::ProcessFoliageList(NameList **FileNamesCreated, const char *OutputFilePath)
{
int Success = 1;

return (Success);

} // ExportFormatVRML::ProcessFoliageList

/*===========================================================================*/

void ExportFormatVRML::ProcessMatTexture(long MatCt, FILE *fVRML, Object3DEffect *CurObj)
{
MaterialEffect *Mat;
RootTexture *RootTex;
Texture *UVTex;
Raster *Rast;
long UseImage = 0;
long DiffuseAlphaAvailable = 0;
char TextureName[256];

if (! CurObj->NameTable[MatCt].Mat)
	CurObj->NameTable[MatCt].Mat = (MaterialEffect *)GlobalApp->AppEffects->FindByName(WCS_EFFECTSSUBCLASS_MATERIAL, CurObj->NameTable[MatCt].Name);

if (Mat = CurObj->NameTable[MatCt].Mat)
	{
	if (Mat->ShortName[0])
		{
		strncpy(TextureName, Mat->ShortName, 16);
		TextureName[16] = 0;
		} // if
	else
		{
		sprintf(TextureName, "OM%06d", MatCt);
		strcpy(Mat->ShortName, TextureName);
		} // else

	if (CurObj->VertexUVWAvailable)
		{
		if (RootTex = Mat->GetTexRootPtr(WCS_EFFECTS_MATERIAL_TEXTURE_DIFFUSECOLOR))
			{
			if (UVTex = RootTex->Tex)
				{
				if (UVTex->TexType == WCS_TEXTURE_TYPE_UVW)
					{
					if (UVTex->Img && (Rast = UVTex->Img->GetRaster()))
						{
						if (CheckAndShortenFileName(TextureName, Rast->GetPath(), Rast->GetName(), 12))
							Rast->PAF.SetName(TextureName);
						UseImage = 1;
						} // if
					} // if
				} // if
			} // if
		if (RootTex = Mat->GetTexRootPtr(WCS_EFFECTS_MATERIAL_TEXTURE_TRANSPARENCY))
			{
			if (UVTex = RootTex->Tex)
				{
				if (UVTex->TexType == WCS_TEXTURE_TYPE_UVW)
					{
					if (UVTex->Img && (Rast = UVTex->Img->GetRaster()))
						{
						if (CheckAndShortenFileName(TextureName, Rast->GetPath(), Rast->GetName(), 12))
							Rast->PAF.SetName(TextureName);
						UseImage = 1;
						} // if
					} // if
				} // if
			} // if
		else if (DiffuseAlphaAvailable)
			{
			if (RootTex = Mat->GetTexRootPtr(WCS_EFFECTS_MATERIAL_TEXTURE_DIFFUSECOLOR))
				{
				if (UVTex = RootTex->Tex)
					{
					if (UVTex->TexType == WCS_TEXTURE_TYPE_UVW)
						{
						if (UVTex->Img && (Rast = UVTex->Img->GetRaster()))
							{
							if (CheckAndShortenFileName(TextureName, Rast->GetPath(), Rast->GetName(), 12))
								Rast->PAF.SetName(TextureName);
							UseImage = 1;
							} // if
						} // if
					} // if
				} // if
			} // else
		} // if
	} // if
else
	{
	sprintf(TextureName, "OM%06d", MatCt);
	} // else

if (UseImage)
	{
	fprintf(fVRML, "        texture ImageTexture {\n");
	fprintf(fVRML, "         url \"%s\"\n", Rast->GetName());
	fprintf(fVRML, "         repeatS FALSE\n         repeatT FALSE\n        }\n");
	} // if

} // ExportFormatVRML::ProcessMatTexture

/*===========================================================================*/
/*===========================================================================*/

ExportFormatVRMLSTL::ExportFormatVRMLSTL(SceneExporter *MasterSource, Project *ProjectSource, EffectsLib *EffectsSource, Database *DBSource, ImageLib *ImageSource)
: ExportFormatVRML(MasterSource, ProjectSource, EffectsSource, DBSource, ImageSource)
{

} // ExportFormatVRMLSTL::ExportFormatVRMLSTL

/*===========================================================================*/

float ExportFormatVRMLSTL::MinElev(FILE *RawElevs, long Cols, long Rows)
{
float  min = FLT_MAX, val;
long i, j = Cols * Rows, k = 0;

//rewind(RawElevs);
for (i = 0; i < j; i++)
	{
	fread(&val, 1, 4, RawElevs);
	if ((val != -9999.0f) && (val < min))
		min = val;
	} // for

if (min == -9999.0f)
	val = 0.0f;

//rewind(RawElevs);
return min;

} // ExportFormatVRMLSTL::MinElev

/*===========================================================================*/

int ExportFormatVRMLSTL::PackageExport(NameList **FileNamesCreated)
{
double offset = 0.001, xmin, xmax, ymin, ymax, zmin, zmax, scalefactor = 1.0, xrange, yrange, zrange, dX, dY, xpos, ypos, VertExag = 1.0;
double GeoCtrLon, GeoCtrLat, LonScale, X, Y;
double MinThickness = 1.0;
float cx, cz, speed, /*** sizex, sizey, ***/ sx, sz, xspace, zspace, xlate, ylate, zlate, zbase;
float xout, yout, zout;
int Success = 1;
long BuildToFit = 0;
long DatPt, FileType, scancol, scanrow, Tiles = 0, XTile, YTile;
long tilesizex, tilesizey;
// defines for quicker debugging
#ifdef WCS_BUILD_FRANK
//#define VRMLSTL_NOBOTTOM
#endif // WCS_BUILD_FRANK
const char *RawTerrainFile, *TextureFile, *OutputFilePath, *IndexFileName, *DataFileName;
FILE *fVRML = NULL;
FILE *fRaw = NULL, *fTexture = NULL, *ffile = NULL;
PathAndFile SceneOutput;
char TempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN]; //, TempFullPathB[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];
class TerrainWriter *TW = NULL;
RealtimeFoliageIndex Index;
RealtimeFoliageCellData RFCD;
RealtimeFoliageData FolData;
char FileName[512], TestFileVersion;
FoliagePreviewData PointData;
long AnimCams = 0, Illuminate3D = 0;
RasterAnimHostProperties Prop;
RenderJob *RJob;
float ElevAdjust;
size_t LineSize;
float *Line1 = NULL, *Line2 = NULL;
float FourCorners[4][2];
unsigned long CoordsCount = 0;
char FullFileName[512];

if (GlobalApp->MainProj->Prefs.PrivateQueryConfigOpt("VRMLSTLinX3D"))
	X3D = true;
else
	X3D = false;

if ((Master->FormatExtension) && (Master->FormatExtension->GetType() == WCS_EFFECTS_SCENEEXPORTER_EXTENSIONTYPE_STL))
	{
	class SXExtensionSTL *SXExtSTL = (class SXExtensionSTL *)Master->FormatExtension;

	BuildEnvelope[0] = (float)SXExtSTL->ActualDimX;
	BuildEnvelope[1] = (float)SXExtSTL->ActualDimY;
	BuildEnvelope[2] = (float)SXExtSTL->ActualDimZ;
	VertExag = SXExtSTL->VertExag / 100.0;
	MinThickness = SXExtSTL->MinThickness;
	if (SXExtSTL->BuildMode == WCS_EFFECTS_SXEXTENSION_BUILDMODE_TOFIT)
		BuildToFit = 1;
	else
		scalefactor = SXExtSTL->BuildScale / 100.0;
	if (SXExtSTL->UnitOfMeasure == WCS_EFFECTS_SXEXTENSION_BUILDUNIT_INCHES)
		scalefactor = 1.0 / 25.4;
	} // if
else
	{
	// shouldn't get here, but set some default just in case
	// defaults to Z Corp's Z406 dimension
	BuildEnvelope[0] = 254.0f;
	BuildEnvelope[1] = 203.0f;
	BuildEnvelope[2] = 203.0f;
	VertExag = 1.0;
	MinThickness = 1;
	BuildToFit = 1;
	} // else

if ((Master->DEMTilesX > 1) || (Master->DEMTilesY > 1))
	{
	Tiles = 1;
	FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	RawTerrainFile = NULL;
	RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
	fRaw = PROJ_fopen(RawTerrainFile, "rb");

	FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
	TextureFile = NULL;
	TextureFile = (*FileNamesCreated)->FindNextNameOfType(FileType, TextureFile);

	tilesizex = (long)((Master->DEMResX + Master->DEMTilesX - 1) / Master->DEMTilesX);
	tilesizey = (long)((Master->DEMResY + Master->DEMTilesY - 1) / Master->DEMTilesY);
	} // if tiles
else
	{
	FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	RawTerrainFile = (*FileNamesCreated)->FindNameOfType(FileType);
	fRaw = PROJ_fopen(RawTerrainFile, "rb");

	FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
	TextureFile = (*FileNamesCreated)->FindNameOfType(FileType);
	tilesizex = Master->DEMResX;
	tilesizey = Master->DEMResY;
	} // else tiles

if (!(RJob = new RenderJob))
	{
	Success = 0;
	GlobalApp->StatusLog->PostError(WCS_LOG_SEVERITY_ERR, "VRMLSTL Export aborted - critically short on memory!");
	goto Cleanup;
	} // if

// The directory where all the files should be created is:
OutputFilePath = Master->OutPath.GetPath();

SceneOutput.SetPath((char *)Master->OutPath.GetPath());
SceneOutput.SetName((char *)Master->OutPath.GetName());
if (X3D)
	SceneOutput.GetFramePathAndName(TempFullPath, ".x3dv", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
else
	SceneOutput.GetFramePathAndName(TempFullPath, ".wrl", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);

GeoCtrLon = Master->ExportRefData.ExportRefLon;
GeoCtrLat = Master->ExportRefData.ExportRefLat;
LonScale = Master->ExportRefData.ExportLonScale;
//ElevAdjust = (float)(-Master->ExportRefData.RefElev);

tilesizex = Master->DEMResX;
tilesizey = Master->DEMResY;

strcpy(TempFullPath, GlobalApp->MainProj->MungPath(TempFullPath));
fVRML = fopen(TempFullPath, "w+"); // w+ ???

LineSize = Master->OneDEMResX * sizeof(float);
Line1 = (float *)AppMem_Alloc(LineSize, 0);
Line2 = (float *)AppMem_Alloc(LineSize, 0);
if ((Line1 == NULL) || (Line2 == NULL))
	GlobalApp->StatusLog->PostError(WCS_LOG_SEVERITY_ERR, "VRMLSTL Export aborted - critically short on memory!");

if (TW = new TerrainWriter)
	{
	TW->EmitType = WCS_TERRAINWRITER_ASCII;
	} // if TW

if (fRaw)
	{
	// find the minimum elev
	zmin = FLT_MAX;
	if (Tiles)
		{
		FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
		// scan tiles for min elev
		for (long ndx = 0, YTile = 0; YTile < Master->DEMTilesY; YTile++)
			{
			for (XTile = 0; XTile < Master->DEMTilesX; XTile++, ndx++)
				{
				float ztmp;
				ztmp = MinElev(fRaw, tilesizex, tilesizey);
				if (ztmp < zmin)
					zmin = ztmp;
				fclose(fRaw);
				RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
				fRaw = PROJ_fopen(RawTerrainFile, "rb");
				} // for XTile
			} // for YTile
		// reset back to the first tile
		RawTerrainFile = NULL;
		RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
		fRaw = PROJ_fopen(RawTerrainFile, "rb");
		} // if Tiles
	else
		{
		zmin = MinElev(fRaw, tilesizex, tilesizey);
		} // else Tiles
	} // if fRaw

ElevAdjust = (float)-zmin;

if (Line1 && Line2 && fRaw && fVRML && TW)
	{
	xspace = (float)(Master->RBounds.CellSizeX * Master->ExportRefData.ExportLonScale);
	zspace = (float)(Master->RBounds.CellSizeY * Master->ExportRefData.ExportLatScale);
	sx = (float)(((Master->DEMResX - 1) * Master->RBounds.CellSizeX) * Master->ExportRefData.ExportLonScale);	// size x
	sz = (float)(((Master->DEMResY - 1) * Master->RBounds.CellSizeY) * Master->ExportRefData.ExportLatScale);
	cx = sx * 0.5f;	// center x
	cz = sz * 0.5f;

	if (sx > sz)
		speed = (float)sx;
	else
		speed = (float)sz;
	speed /= 7.0f;	// no more than 7 seconds to cross our terrain

	xmin = 0.0;
	ymin = 0.0;
	xmax = sx;
	ymax = sz;
	//zmin = Master->ExportRefData.RefElev;
	zmax = Master->ExportRefData.MaxElev;
	xrange = xmax - xmin;
	yrange = ymax - ymin;
	zrange = (zmax * VertExag) - (zmin * VertExag);
	if (BuildToFit)
		{
		double xfactor, yfactor, zfactor;

		// find out which dimension needs to be scaled the most, use the inverse of that as the scaling factor
		xfactor = xrange / (BuildEnvelope[0] - offset);	// offset required since 0.0 isn't a valid Stl coordinate
		yfactor = yrange / (BuildEnvelope[1] - offset);
		zfactor = zrange / (BuildEnvelope[2] - offset);
		if (xfactor >= yfactor)
			{
			if (xfactor >= zfactor)
				scalefactor = 1.0 / xfactor;
			else
				scalefactor = 1.0 / zfactor;
			} // if
		else if (yfactor >= zfactor)
			{
			scalefactor = 1.0 / yfactor;
			} // else if
		else
			{
			scalefactor = 1.0 / zfactor;
			}
		} // if BuildToFit
	else
		{
		// Build to scale
		} // else
	TW->EmitScale = (float)scalefactor;
	TW->EmitOffset = (float)offset;
	xspace = (float)(xspace * scalefactor);
	zspace = (float)(zspace * scalefactor);
	speed = (float)(speed * scalefactor);
	dX = xrange / (Master->DEMResX - 1);
	dY = yrange / (Master->DEMResY - 1);

	VRML_Header_WorldInfo(fVRML);

	fprintf(fVRML, "NavigationInfo {\n headlight FALSE\n speed %f\n type [\"FLY\", \"ANY\"]\n}\n", speed);

	// Viewpoints
	if (Master->ExportCameras)
		{
		class EffectList *CamList = Master->Cameras;
		class Camera *Cam;

		while (CamList)
			{
			Point4d AxisAngle;
			Point3d Orient;
			//double rot;
			float LookAt[3], LookFrom[3];

			Cam = (class Camera *)CamList->Me;
			fprintf(fVRML, "\nViewpoint {\n");
			LookAt[0] = LookAt[1] = LookAt[2] = 0.0f;
			// convert geographic position to meters & our repositioning
			Master->RBounds.DefDegToRBounds(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLAT].CurValue, Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMLON].CurValue, X, Y);
			LookFrom[0] = (float)((X - GeoCtrLon) * Master->ExportRefData.ExportLonScale);
			LookFrom[1] = (float)((Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_CAMELEV].CurValue - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
			LookFrom[2] = (float)((GeoCtrLat - Y) * Master->ExportRefData.ExportLatScale);
			fprintf(fVRML, " position %f %f %f\n", LookFrom[0], LookFrom[1], LookFrom[2]);
			if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_UNTARGETED)
				{
				Orient[0] = -Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_PITCH].CurValue;
				Orient[1] = -Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_HEADING].CurValue;
				Orient[2] = Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_BANK].CurValue;
				} // if untargeted
			else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_TARGETED)
				{
				Orient[0] = -Cam->CamPitch;
				Orient[1] = -Cam->CamHeading;
				Orient[2] = Cam->CamBank;
				} // else if targeted
			else if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_OVERHEAD)
				{
				Orient[0] = -Cam->CamPitch;
				Orient[1] = -Cam->CamHeading;
				Orient[2] = Cam->CamBank;
				} // else if overhead
			if (Cam->CameraType == WCS_EFFECTS_CAMERATYPE_ALIGNED)
				{
				Orient[0] = -Cam->CamPitch;
				Orient[1] = -Cam->CamHeading;
				Orient[2] = Cam->CamBank;
				} // if untargeted
			EulerToAxisAngle(Orient, AxisAngle);
			AxisAngle[3] *= PiOver180;
			fprintf(fVRML, " orientation %f %f %f %f\n", (float)AxisAngle[0], (float)-AxisAngle[1], (float)-AxisAngle[2], (float)AxisAngle[3]);
			fprintf(fVRML, " fieldOfView %f\n", (float)(Cam->AnimPar[WCS_EFFECTS_CAMERA_ANIMPAR_HFOV].CurValue * PiOver180));
			fprintf(fVRML, " description \"%s\"\n}\n", Cam->Name);

			CamList = CamList->Next;
			} // while CamList
		} // if Cameras
	// a default overhead because VRML navigation is painful
	fprintf(fVRML, "\nViewpoint {\n");
	fprintf(fVRML, " position %f %f %f\n", cx * scalefactor,
		(Master->ExportRefData.MaxElev + sx + sz - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale * scalefactor,
		cz * scalefactor);
	fprintf(fVRML, " orientation 1 0 0 -1.570796\n");
	fprintf(fVRML, " description \"Top View\"\n}\n");

	// lights
	if (Master->ExportLights)
		{
		double X, Y;
		float tmp[3];
		class EffectList *LiteList = Master->Lights;
		class Light *Lite;

		while (LiteList)
			{
			Lite = (class Light *)LiteList->Me;
			if (Lite->Enabled)
				Illuminate3D = 1;	// if any enabled lights are exported, illuminate 3d objects
			switch (Lite->LightType)
				{
				default:
				case WCS_EFFECTS_LIGHTTYPE_PARALLEL:
					{
					tmp[0] = (float)Lite->Color.CurValue[0];
					tmp[1] = (float)Lite->Color.CurValue[1];
					tmp[2] = (float)Lite->Color.CurValue[2];
					fprintf(fVRML, "\nDirectionalLight {\n");
					fprintf(fVRML, " color %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					tmp[0] = (float)Lite->LightAim->XYZ[0];
					tmp[1] = (float)Lite->LightAim->XYZ[1];
					tmp[2] = (float)Lite->LightAim->XYZ[2];
					fprintf(fVRML, " direction %f %f %f\n", -tmp[0], tmp[1], tmp[2]);
					fprintf(fVRML, " ambientIntensity %f\n", 0.75f);
					tmp[0] = (float)min(1.0, Lite->Color.Intensity.CurValue);
					fprintf(fVRML, " intensity %f\n", tmp[0]);
					if (Lite->Enabled)
						fprintf(fVRML, " on TRUE\n}\n");
					else
						fprintf(fVRML, " on FALSE\n}\n");
					}
					break;
				case WCS_EFFECTS_LIGHTTYPE_OMNI:
					{
					fprintf(fVRML, "\nPointLight {\n");
					fprintf(fVRML, " attenuation 1 0 0\n");
					tmp[0] = (float)Lite->Color.CurValue[0];
					tmp[1] = (float)Lite->Color.CurValue[1];
					tmp[2] = (float)Lite->Color.CurValue[2];
					fprintf(fVRML, " color %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					tmp[0] = (float)min(1.0, Lite->Color.Intensity.CurValue);
					fprintf(fVRML, " intensity %f\n", tmp[0]);
					Master->RBounds.DefDegToRBounds(Lite->LightPos->Lat, Lite->LightPos->Lon, X, Y);
					tmp[0] = (float)((X - Master->ExportRefData.ExportRefLon) * Master->ExportRefData.ExportLonScale);
					tmp[1] = (float)((Lite->LightPos->Elev - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
					tmp[2] = (float)-((Y - Master->ExportRefData.ExportRefLat) * Master->ExportRefData.ExportLatScale);
					fprintf(fVRML, " location %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					if (Lite->Enabled)
						fprintf(fVRML, " on TRUE\n");
					else
						fprintf(fVRML, " on FALSE\n");
					tmp[0] = (float)min(500000, Lite->MaxIllumDist);
					fprintf(fVRML, " radius %f\n}\n", tmp[0]);
					}
					break;
				case WCS_EFFECTS_LIGHTTYPE_SPOT:
					{
					tmp[0] = (float)Lite->Color.CurValue[0];
					tmp[1] = (float)Lite->Color.CurValue[1];
					tmp[2] = (float)Lite->Color.CurValue[2];
					fprintf(fVRML, "\nSpotLight {\n");
					fprintf(fVRML, " attenuation 1 0 0\n");
					fprintf(fVRML, " beamWidth %f\n", (float)(Lite->AnimPar[WCS_EFFECTS_LIGHT_ANIMPAR_SPOTCONEEDGE].CurValue * PiOver180));
					fprintf(fVRML, " color %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					fprintf(fVRML, " cutOffAngle %f\n", (float)(Lite->AnimPar[WCS_EFFECTS_LIGHT_ANIMPAR_SPOTCONE].CurValue * PiOver180));
					tmp[0] = -(float)Lite->LightAim->XYZ[0];
					tmp[1] = (float)Lite->LightAim->XYZ[1];
					tmp[2] = (float)Lite->LightAim->XYZ[2];
					fprintf(fVRML, " direction %f %f %f\n", tmp[0], tmp[2], tmp[1]);
					tmp[0] = (float)min(1.0, Lite->Color.Intensity.CurValue);
					fprintf(fVRML, " intensity %f\n", tmp[0]);
					Master->RBounds.DefDegToRBounds(Lite->LightPos->Lat, Lite->LightPos->Lon, X, Y);
					tmp[0] = (float)((X - Master->ExportRefData.ExportRefLon) * Master->ExportRefData.ExportLonScale);
					tmp[1] = (float)((Lite->LightPos->Elev - Master->ExportRefData.RefElev) * Master->ExportRefData.ElevScale);
					tmp[2] = (float)-((Y - Master->ExportRefData.ExportRefLat) * Master->ExportRefData.ExportLatScale);
					fprintf(fVRML, " location %f %f %f\n", tmp[0], tmp[1], tmp[2]);
					if (Lite->Enabled)
						fprintf(fVRML, " on TRUE\n");
					else
						fprintf(fVRML, " on FALSE\n");
					fprintf(fVRML, " radius %f\n}\n", 100.0f); // (float)Lite->MaxIllumDist);
					}
					break;
				} // switch LightType
			LiteList = LiteList->Next;
			} // while LiteList
		} // if Lights
	else
		{
		fprintf(fVRML, "\nDirectionalLight {\n");
		fprintf(fVRML, " ambientIntensity 0.75\n direction 0.612372 -0.500000 0.612372\n}\n");
		} // else Lights

	// the terrain
	if (Master->ExportTerrain)
		{
		FILE *fVRMLmaster = NULL;
		char indent[8];

		if (Tiles)
			fVRMLmaster = fVRML;

		// top surface
		for (YTile = 0; YTile < Master->DEMTilesY; YTile++)
			{
			for (XTile = 0; XTile < Master->DEMTilesX; XTile++)
				{
				const char *OutputFilePath;
				float lod_xspace, lod_zspace, xdist, xtileoffset, zdist, ztileoffset;
				long lod_tilesizex, lod_tilesizey;

				if (Tiles)
					{
					char TileIndex[16];

					sprintf(TileIndex, "Tile%02dx%02dy.wrl", XTile, YTile);
					strmfp(FullFileName, Master->OutPath.Path, TileIndex);
					fVRML = PROJ_fopen(FullFileName, "w");

					VRML_Header_WorldInfo(fVRML);
					} // if Tiles

				XStep = (float)(Master->RBounds.CellSizeX * scalefactor);
				ZStep = (float)(Master->RBounds.CellSizeY * scalefactor);
				//xlate = -cx + sx / Master->DEMTilesX * XTile;
				xlate = (float)(sx / Master->DEMTilesX * XTile * scalefactor + offset);
				ylate = 0.0f;
				zlate = -cz + sz / Master->DEMTilesY * YTile;
				zlate = (float)(sz / Master->DEMTilesY * YTile * scalefactor + offset);
				xtileoffset = (float)(XTile * (Master->OneDEMResX - 1) * XStep);
				ztileoffset = (float)(YTile * (Master->OneDEMResY - 1) * ZStep);
				//fprintf(fVRML, "Group {\n children [\n  Transform {\n   translation %f %f %f\n   children [\n",
				//	xlate, ylate, zlate);
				fprintf(fVRML, "Group {\n children [\n  Transform {\n   translation %f %f %f\n   children [\n",
					xtileoffset, ylate, ztileoffset);
				lod_tilesizex = Master->OneDEMResX;
				lod_tilesizey = Master->OneDEMResY;
				lod_xspace = xspace;
				lod_zspace = zspace;
				xdist = (tilesizex - 1) * xspace;
				zdist = (tilesizey - 1) * zspace;
				strcpy(indent, " ");
				OutputFilePath = Master->OutPath.GetPath();

				fprintf(fVRML, "%s   Shape {\n", indent);
				if (Master->ExportTexture)
					{
					//float xlate, xscale, zlate, zscale;

					fprintf(fVRML, "%s     appearance Appearance {\n", indent);
					/***
					fprintf(fVRML, "%s      textureTransform TextureTransform {\n", indent);
					xscale = 1.0f;
					//zscale = -1.0f;
					zscale = 1.0f;
					xlate = 0.0f;
					// align the t origin with the tiles natural (non-flap) border
					//zlate = -1.0f;
					zlate = 0.0f;
					fprintf(fVRML, "%s       translation %f %f\n%s       scale %f %f\n%s      }\n",
						indent, xlate, zlate, indent, xscale, zscale, indent);
					***/
					/***
					fprintf(fVRML, "%s      material Material {\n", indent);
					fprintf(fVRML, "%s       ambientIntensity 0.45\n", indent);
					fprintf(fVRML, "%s       diffuseColor 1.0 1.0 1.0\n", indent);
					fprintf(fVRML, "%s      }\n", indent);
					***/
					fprintf(fVRML, "%s      material Material {\n", indent);
					fprintf(fVRML, "%s       ambientIntensity 0\n", indent);
					fprintf(fVRML, "%s       diffuseColor 0 0 0\n", indent);
					fprintf(fVRML, "%s       emissiveColor 1 1 1\n", indent);
					fprintf(fVRML, "%s      }\n", indent);
					fprintf(fVRML, "%s      texture ImageTexture {\n", indent);
					fprintf(fVRML, "%s       url \"%s\"\n", indent, TextureFile);
					fprintf(fVRML, "%s       repeatS FALSE\n%s       repeatT FALSE\n%s      }\n%s     }\n", indent, indent, indent, indent);
					} // if
				ScaleFactor = scalefactor;
				//XStep = lod_xspace;
				//ZStep = lod_zspace;
				Gen_IFS_Elevs(fRaw, fVRML, ElevAdjust, lod_tilesizex, lod_tilesizey);
				rewind(fRaw);	// ???
/***
				fprintf(fVRML, "%s     geometry ElevationGrid {\n", indent);
				fprintf(fVRML, "%s      solid FALSE\n", indent);
				fprintf(fVRML, "%s      xDimension %d\n", indent, lod_tilesizex);
				fprintf(fVRML, "%s      zDimension %d\n", indent, lod_tilesizey);
				fprintf(fVRML, "%s      xSpacing %f\n", indent, lod_xspace);
				fprintf(fVRML, "%s      zSpacing %f\n", indent, lod_zspace);
				fprintf(fVRML, "%s      height [\n", indent);

				// "Automatically" save the elev model
				TW->EmitTerrain(lod_tilesizex, lod_tilesizey, fRaw, fVRML, ElevAdjust, 0.0f, 0, 0);
				rewind(fRaw);
***/

				fprintf(fVRML, "\n%s     ]\n", indent);
				// workaround for Z Corporations ZPrint bug
				fprintf(fVRML, "      texCoord TextureCoordinate {\n       point [\n");
				//for (long t = 0; t < lod_tilesizey; t++)
				for (long t = (lod_tilesizey - 1); t >= 0; t--)
					{
					for (long s = 0; s < lod_tilesizex; s++)
						{
						static long pairs = 0;
						fprintf(fVRML, "%f %f  ", s / (float)(lod_tilesizex - 1), t / (float)(lod_tilesizey - 1));
						pairs++;
						if ((pairs % 7) == 0)
							fprintf(fVRML, "\n");
						} // for s
					} // for t
				fprintf(fVRML, "\n       ]\n      }\n");
				fprintf(fVRML, "%s    }\n%s   } # End Shape (Top)\n", indent, indent);

				// create a north wall
				rewind(fRaw);
				fread(Line1, 1, LineSize, fRaw);
				fprintf(fVRML, "# North wall\n");
				strcpy(indent, "    ");
				fprintf(fVRML, "%s Shape {\n%s  appearance Appearance {\n%s   material Material {\n", indent, indent, indent);
				fprintf(fVRML, "%s    diffuseColor 0 0 0\n%s    emissiveColor 1 1 1%s   }\n%s  }\n", indent, indent, indent, indent);
				fprintf(fVRML, "%s  geometry IndexedFaceSet {\n%s   coord Coordinate {\n%s    point [", indent, indent, indent);
				xpos = 0.0;
				ypos = 0.0;
				zbase = (float)(MinThickness + offset);
				//for (scancol = 0; scancol < lod_tilesizex; scancol++, xpos += lod_xspace)
				for (scancol = 0; scancol < lod_tilesizex; scancol++, xpos += XStep)
					{
					/***

					Viewed from North:

					... 4 --- 2 --- 0
						|\    |\    |
						|  \  |  \  |
						|    \|    \|
					... 5 --- 3 --- 1

					***/
					// even verts
					xout = (float)xpos;
					yout = (float)(((Line1[scancol] * VertExag - zmin) + zbase) * scalefactor);
					zout = (float)ypos;
					// print no more than 4 triplets per line
					if ((scancol % 2) == 0)
						fprintf(fVRML, "\n%f %f %f", xout, yout, zout);
					else
						fprintf(fVRML, " %f %f %f", xout, yout, zout);
					// odd verts
					yout = (float)offset;
					fprintf(fVRML, " %f %f %f", xout, yout, zout);
					} // for scancol
				fprintf(fVRML, "\n  ]\n }\n");
				fprintf(fVRML, " coordIndex [\n");
				for (scancol = 0; scancol < (lod_tilesizex - 1); scancol++)
					{
					long basevert = scancol * 2;

					// lower left triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert + 2, basevert + 3, basevert + 1);
					// upper right triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert, basevert + 2, basevert + 1);
					} // for scancol
				fprintf(fVRML, "%s   ]\n%s  }\n%s } # End Shape (North wall)\n", indent, indent, indent);	// solid TRUE is default

				// create a south wall
				rewind(fRaw);
				fseek(fRaw, lod_tilesizex * sizeof(float) * (lod_tilesizey - 1), SEEK_SET);	// we only want the last scanline
				fread(Line1, 1, LineSize, fRaw);
				fprintf(fVRML, "# South wall\n");
				strcpy(indent, "    ");
				fprintf(fVRML, "%s Shape {\n%s  appearance Appearance {\n%s   material Material {\n", indent, indent, indent);
				fprintf(fVRML, "%s    diffuseColor 0 0 0\n%s    emissiveColor 1 1 1%s   }\n%s  }\n", indent, indent, indent, indent);
				fprintf(fVRML, "%s  geometry IndexedFaceSet {\n%s   coord Coordinate {\n%s    point [", indent, indent, indent);
				xpos = 0.0;
				ypos = (lod_tilesizey - 1) * lod_zspace;
				zbase = (float)(MinThickness + offset);
				for (scancol = 0; scancol < lod_tilesizex; scancol++, xpos += lod_xspace)
					{
					/***

					Viewed from South:

					0 --- 2 --- 4 ...
					|\    |\    |
					|  \  |  \  |
					|    \|    \|
					1 --- 3 --- 5 ...

					***/
					// even verts
					xout = (float)xpos;
					yout = (float)(((Line1[scancol] * VertExag - zmin) + zbase) * scalefactor);
					zout = (float)ypos;
					// print no more than 4 triplets per line
					if ((scancol % 2) == 0)
						fprintf(fVRML, "\n%f %f %f", xout, yout, zout);
					else
						fprintf(fVRML, " %f %f %f", xout, yout, zout);
					// odd verts
					yout = (float)offset;
					fprintf(fVRML, " %f %f %f", xout, yout, zout);
					} // for scancol
				fprintf(fVRML, "\n  ]\n }\n");
				fprintf(fVRML, " coordIndex [\n");
				for (scancol = 0; scancol < (lod_tilesizex - 1); scancol++)
					{
					long basevert = scancol * 2;

					// lower left triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert, basevert + 1, basevert + 3);
					// upper right triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert + 2, basevert, basevert + 3);
					} // for scancol
				fprintf(fVRML, "%s   ]\n%s  }\n%s } # End Shape (South wall)\n", indent, indent, indent);	// solid TRUE is default

				// create a west wall
				rewind(fRaw);
				fprintf(fVRML, "# West wall\n");
				strcpy(indent, "    ");
				fprintf(fVRML, "%s Shape {\n%s  appearance Appearance {\n%s   material Material {\n", indent, indent, indent);
				fprintf(fVRML, "%s    diffuseColor 0 0 0\n%s    emissiveColor 1 1 1%s   }\n%s  }\n", indent, indent, indent, indent);
				fprintf(fVRML, "%s  geometry IndexedFaceSet {\n%s   coord Coordinate {\n%s    point [", indent, indent, indent);
				xpos = 0.0;
				ypos = 0.0;
				zbase = (float)(MinThickness + offset);
				for (scanrow = 0; scanrow < lod_tilesizey; scanrow++, ypos += lod_zspace)
					{
					fread(Line1, 1, LineSize, fRaw);
					/***

					Viewed from West:

					0 --- 2 --- 4 ...
					|\    |\    |
					|  \  |  \  |
					|    \|    \|
					1 --- 3 --- 5 ...

					***/
					// even verts
					xout = (float)xpos;
					yout = (float)(((Line1[0] * VertExag - zmin) + zbase) * scalefactor);
					zout = (float)ypos;
					// print no more than 4 triplets per line
					if ((scanrow % 2) == 0)
						fprintf(fVRML, "\n%f %f %f", xout, yout, zout);
					else
						fprintf(fVRML, " %f %f %f", xout, yout, zout);
					// odd verts
					yout = (float)offset;
					fprintf(fVRML, " %f %f %f", xout, yout, zout);
					} // for scanrow
				fprintf(fVRML, "\n  ]\n }\n");
				fprintf(fVRML, " coordIndex [\n");
				for (scanrow = 0; scanrow < (lod_tilesizey - 1); scanrow++)
					{
					long basevert = scanrow * 2;

					// lower left triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert, basevert + 1, basevert + 3);
					// upper right triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert + 2, basevert, basevert + 3);
					} // for scanrow
				fprintf(fVRML, "%s   ]\n%s  }\n%s } # End Shape (West wall)\n", indent, indent, indent);	// solid TRUE is default

				// create a east wall
				rewind(fRaw);
				fprintf(fVRML, "# East wall\n");
				fprintf(fVRML, "%s Shape {\n%s  appearance Appearance {\n%s   material Material {\n", indent, indent, indent);
				fprintf(fVRML, "%s    diffuseColor 0 0 0\n%s    emissiveColor 1 1 1%s   }\n%s  }\n", indent, indent, indent, indent);
				fprintf(fVRML, "%s  geometry IndexedFaceSet {\n%s   coord Coordinate {\n%s    point [", indent, indent, indent);
				xpos = (lod_tilesizex - 1) * lod_xspace;
				ypos = 0.0;
				zbase = (float)(MinThickness + offset);
				for (scanrow = 0; scanrow < lod_tilesizey; scanrow++, ypos += lod_zspace)
					{
					fread(Line1, 1, LineSize, fRaw);
					/***

					Viewed from East:

					... 4 --- 2 --- 0
						|\    |\    |
						|  \  |  \  |
						|    \|    \|
					... 5 --- 3 --- 1

					***/
					// even verts
					xout = (float)xpos;
					yout = (float)(((Line1[lod_tilesizex - 1] * VertExag - zmin) + zbase) * scalefactor);
					zout = (float)ypos;
					// print no more than 4 triplets per line
					if ((scanrow % 2) == 0)
						fprintf(fVRML, "\n%f %f %f", xout, yout, zout);
					else
						fprintf(fVRML, " %f %f %f", xout, yout, zout);
					// odd verts
					yout = (float)offset;
					fprintf(fVRML, " %f %f %f", xout, yout, zout);
					} // for scanrow
				fprintf(fVRML, "\n  ]\n }\n");
				fprintf(fVRML, " coordIndex [\n");
				for (scanrow = 0; scanrow < (lod_tilesizey - 1); scanrow++)
					{
					long basevert = scanrow * 2;

					// lower left triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert + 2, basevert + 3, basevert + 1);
					// upper right triangle
					fprintf(fVRML, "  %d %d %d -1\n", basevert, basevert + 2, basevert + 1);
					} // for scanrow
				fprintf(fVRML, "%s   ]\n%s  }\n%s } # End Shape (East wall)\n", indent, indent, indent);	// solid TRUE is default

				// cache the corner coords
				if (Tiles)
					{
					FourCorners[0][0] = (float)offset;
					FourCorners[0][1] = (float)offset;
					FourCorners[1][0] = (float)(offset + (Master->OneDEMResX - 1) * XStep);
					FourCorners[1][1] = (float)offset;
					FourCorners[2][0] = (float)offset;
					FourCorners[2][1] = (float)(offset + (Master->OneDEMResY - 1) * ZStep);
					FourCorners[3][0] = (float)(offset + (Master->OneDEMResX - 1) * XStep);
					FourCorners[3][1] = (float)(offset + (Master->OneDEMResY - 1) * ZStep);
					} // if
				else
					{
					if (YTile == 0)
						{
						// NW
						if (XTile == 0)
							{
							FourCorners[0][0] = xlate;
							FourCorners[0][1] = zlate;
							} // if

						// NE
						if (XTile == (Master->DEMTilesX - 1))
							{
							//FourCorners[1][0] = xlate + (lod_tilesizex - 1) * lod_xspace;
							FourCorners[1][0] = xlate + xdist;
							FourCorners[1][1] = zlate;
							} // if
						} // if

					if (YTile == (Master->DEMTilesY - 1))
						{
						// SW
						if (XTile == 0)
							{
							FourCorners[2][0] = xlate;
							//FourCorners[2][1] = zlate + (lod_tilesizey - 1) * lod_zspace;
							FourCorners[2][1] = zlate + zdist;
							} // if

						// SE
						if (XTile == (Master->DEMTilesX - 1))
							{
							//FourCorners[3][0] = xlate + (lod_tilesizex - 1) * lod_xspace;
							//FourCorners[3][1] = zlate + (lod_tilesizey - 1) * lod_zspace;
							FourCorners[3][0] = xlate + xdist;
							FourCorners[3][1] = zlate + zdist;
							} // if
						} // if
					} // else

#ifndef VRMLSTL_NOBOTTOM	// easy way to see interior surface
				// Add the bottom face
				/***

				Viewed from Bottom:

				1 --- 0
				|\    |
				|  \  |
				|    \|
				3 --- 2

				***/
				fprintf(fVRML, "# Bottom");
				fprintf(fVRML, "\nShape {\n appearance Appearance {\n  material Material {\n");
				fprintf(fVRML, "   diffuseColor 0 0 0\n   emissiveColor 1 1 1\n  }\n }\n");
				fprintf(fVRML, " geometry IndexedFaceSet {\n  coord Coordinate {\n   point [\n");
				fprintf(fVRML, "    %f %f %f,", FourCorners[0][0], offset, FourCorners[0][1]);
				fprintf(fVRML, " %f %f %f,", FourCorners[1][0], offset, FourCorners[1][1]);
				fprintf(fVRML, " %f %f %f,", FourCorners[2][0], offset, FourCorners[2][1]);
				fprintf(fVRML, " %f %f %f\n   ]\n  }\n", FourCorners[3][0], offset, FourCorners[3][1]);
				fprintf(fVRML, "  coordIndex [\n");
				fprintf(fVRML, "   1 3 2 -1\n");
				fprintf(fVRML, "   0 1 2 -1\n");
				fprintf(fVRML, "  ]\n }\n} # End Shape (Bottom)\n");
#endif // VRMLSTL_NOBOTTOM

				if (Tiles)
					{
					fprintf(fVRML, "]}]}\n");
					} // if

				if (fRaw)
					{
					fclose(fRaw);
					fRaw = NULL;
					} // if

				if (Tiles)
					{
					if (fVRML)
						fclose(fVRML);

					FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
					RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile);
					fRaw = PROJ_fopen(RawTerrainFile, "rb");

					FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
					TextureFile = (*FileNamesCreated)->FindNextNameOfType(FileType, TextureFile);
					} // if tiles

				fprintf(fVRML, "   ]\n  }\n ]\n} # End Group\n");	// close Group

				} // for XTile
			} // for YTile


		if (Tiles)
			{
			if (fVRML)
				fclose(fVRML);
			fVRML = fVRMLmaster;
			// put in links to individual tiles
			for (YTile = 0; YTile < Master->DEMTilesY; YTile++)
				{
				for (XTile = 0; XTile < Master->DEMTilesX; XTile++)
					{
					fprintf(fVRML, "\nInline {\n url \"Tile%02dx%02dy.wrl\"\n}\n", XTile, YTile);
					} // for
				} // for
			} // if Tiles

		} // if Master->ExportTerrain

	if (fRaw)
		{
		fclose(fRaw);
		fRaw = NULL;
		} // if

	if (Master->ExportFoliage)
		{
		FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
		if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
			{
			FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
			if (DataFileName = (*FileNamesCreated)->FindNameOfType(FileType))
				{
				//double TexRefLat, TexRefLon, TexRefElev, TexDeltaLat, TexDeltaLon;
				// you've got the two file names that the Renderer wrote out.
				// combine them with the output file path to make a file that can be opened with PROJ_fopen()

				// find and open the index file
				strmfp(FileName, OutputFilePath, IndexFileName);
				if (ffile = PROJ_fopen(FileName, "rb"))
					{
					// read file descriptor, no need to keep it around unless you want to
					fgets(FileName, 256, ffile);
					// version
					fread((char *)&Index.FileVersion, sizeof (char), 1, ffile);
					// number of files
					fread((char *)&Index.NumCells, sizeof (long), 1, ffile);
					// reference XYZ
					fread((char *)&Index.RefXYZ[0], sizeof (double), 1, ffile);
					fread((char *)&Index.RefXYZ[1], sizeof (double), 1, ffile);
					fread((char *)&Index.RefXYZ[2], sizeof (double), 1, ffile);

					if (Index.NumCells > 0)
						{
						// only one cell data entry is provided
						if (Index.CellDat = &RFCD)
							{
							// file name
							fgets(Index.CellDat->FileName, 64, ffile);
							// center XYZ
							fread((char *)&Index.CellDat->CellXYZ[0], sizeof (double), 1, ffile);
							fread((char *)&Index.CellDat->CellXYZ[1], sizeof (double), 1, ffile);
							fread((char *)&Index.CellDat->CellXYZ[2], sizeof (double), 1, ffile);
							// half cube cell dimension
							fread((char *)&Index.CellDat->CellRad, sizeof (double), 1, ffile);
							// number of trees in file
							fread((char *)&Index.CellDat->DatCt, sizeof (long), 1, ffile);
							} // if
						} // if some cells to read
					fclose(ffile);

					if((Index.NumCells > 0) && (Index.CellDat->DatCt > 0))
						{
						strmfp(FileName, OutputFilePath, DataFileName);
						if (ffile = PROJ_fopen(FileName, "rb"))
							{
							Raster *CurRast, *RastLoop;
							long n;

							for (n = 1, RastLoop = Images->GetFirstRast(); RastLoop; RastLoop = Images->GetNextRast(RastLoop), n++)
								{
								char ImageName[256];

								if (CurRast = Images->FindByID(n))
									{
									strcpy(ImageName, CurRast->GetUserName());
									ImageSaverLibrary::StripImageExtension(ImageName);
									strcat(ImageName, "_Fol");
									ReplaceChar(ImageName, '.', '_');
									strcat(ImageName, ImageSaverLibrary::GetDefaultExtension(Master->FoliageImageFormat));
									FileType = WCS_EXPORTCONTROL_FILETYPE_FOLIAGETEX;
									if ((*FileNamesCreated)->FindNameExists(FileType, ImageName))
										{
										// indeed a resampled image has been created for this entry
										// so it is safe to add this entry into the foliage definitions
										fprintf(fVRML, "\nDEF Foliage%d Transform {\n children [\n  Shape {\n", n);
										fprintf(fVRML, "   appearance Appearance {\n    texture ImageTexture {\n");
										strcpy(ImageName, RastLoop->GetUserName());
										ImageSaverLibrary::StripImageExtension(ImageName);
										strcat(ImageName, "_Fol");
										ReplaceChar(ImageName, '.', '_');
										strcat(ImageName, ImageSaverLibrary::GetDefaultExtension(Master->FoliageImageFormat));
										fprintf(fVRML, "     url \"%s\"\n     repeatS FALSE\n     repeatT FALSE\n    }\n   }\n", ImageName);
										// create a square face 1 meter large, and centered at coords (0m 0m 0m)
										fprintf(fVRML, "   geometry IndexedFaceSet {\n    coord Coordinate {\n     point [");
										fprintf(fVRML, " -0.5 -0.5 0.0, 0.5 -0.5 0.0, 0.5 0.5 0.0, -0.5 0.5 0.0 ]\n");
										fprintf(fVRML, "    }\n    coordIndex [");
										fprintf(fVRML, " 0 1 2 -1, 2 3 0 -1 ]\n    solid FALSE\n");
										fprintf(fVRML, "   }\n  }\n ]\n}\n");
										} // if
									} // if
								} // for

							//TexRefLon = Index.RefXYZ[0];
							//TexRefLat = Index.RefXYZ[1];
							//TexRefElev = Index.RefXYZ[2];
							//TexDeltaLon = GeoCtrLon - TexRefLon;
							//TexDeltaLat = GeoCtrLat - TexRefLat;

							fgets(FileName, 64, ffile);
							// version
							fread((char *)&TestFileVersion, sizeof (char), 1, ffile);
							// Pointless version check -- we know we wrote it
							if (TestFileVersion == Index.FileVersion)
								{
								for (DatPt = 0; DatPt < Index.CellDat->DatCt; DatPt ++)
									{
									if (FolData.ReadFoliageRecord(ffile, Index.FileVersion))
										{
										if (FolData.InterpretFoliageRecord(NULL, Images, &PointData)) // don't need full decoding of 3dobjects, just height, etc
											{
											float x, y, z;

											fprintf(fVRML, "\nTransform {\n");
											// Lat & Lon are in geographic relative to the TexRef coords: convert to meters & reposition
											// grh modifed coords, now they are in the export coord sys with positive always to east even if geographic
											x = (float)(FolData.XYZ[0] * Master->ExportRefData.ExportLonScale);
											y = (float)(FolData.XYZ[2] * Master->ExportRefData.ElevScale + (PointData.Height / 2.0));
											z = (float)(-FolData.XYZ[1] * Master->ExportRefData.ExportLatScale);
											fprintf(fVRML, " translation %f %f %f\n children [\n  Billboard {\n   children [\n", x, y, z);
											x = (float)PointData.Width;
											y = (float)PointData.Height;
											z = 1.0f;
											fprintf(fVRML, "    Transform {\n     scale %f %f %f\n", x, y, z);
											if (PointData.FlipX)
												fprintf(fVRML, "     rotation 0 1 0 3.14159\n");
											/***
											if (FolData.ElementID < 0)
												{
												UserMessageOK("Yikes!", "Encountered a Negative Foliage ElementID");
												fprintf(fVRML, "     children USE Foliage%d # Yikes\n    }\n   ]\n  }\n ]\n}\n", -FolData.ElementID);
												}
											else
												fprintf(fVRML, "     children USE Foliage%d\n    }\n   ]\n  }\n ]\n}\n", FolData.ElementID);
											***/
											fprintf(fVRML, "     children USE Foliage%d\n    }\n   ]\n  }\n ]\n}\n", FolData.ElementID);
											} // if
										} // if
									} // for
								// must do this as it's not dynamically allocated and RealtimeFoliageIndex
								// destructor will blow chunks if we don't
								Index.CellDat = NULL;
								} // if
							fclose(ffile);
							} // if
						} // if
					} // if ffile
				} // if DataFileName
			} // if IndexFileName
		} // if ExportFoliage

	// Now process any 3D objects we find
	if (Master->Export3DObjects)
		{
		double geo[3], /* rot[3], */ scale[3], x, y, z; /*, trans[3];*/
		//MaterialEffect *Mat;
		Object3DInstance *ObjectList = Master->ObjectInstanceList;
		Object3DEffect *Object3D;
		//ObjectMaterialEntry *NameTable;
		ObjectPerVertexMap *UVMap = NULL;
		float boxx, boxy, boxz, /* boxctr[3],*/ dx, dy, dz;
		long DidCoords, MatCt, PolyCt, VertCt;

		while (ObjectList)
			{
			Point4d AxisAngle;
			long i;

			DidCoords = 0;
			Object3D = ObjectList->MyObj;
			if (!((Object3D->Vertices && Object3D->Polygons && Object3D->NameTable) || Object3D->OpenInputFile(NULL, FALSE, FALSE, FALSE)))
				goto SkipObject;
			boxx = (float)(Object3D->ObjectBounds[0] - Object3D->ObjectBounds[1]);
			//boxctr[0] = (float)((o3di->MyObj->ObjectBounds[0] + o3di->MyObj->ObjectBounds[1]) / 2.0);
			boxy = (float)(Object3D->ObjectBounds[2] - Object3D->ObjectBounds[3]);
			//boxctr[1] = (float)((o3di->MyObj->ObjectBounds[2] + o3di->MyObj->ObjectBounds[3]) / 2.0);
			boxz = (float)(Object3D->ObjectBounds[4] - Object3D->ObjectBounds[5]);
			//boxctr[2] = (float)((o3di->MyObj->ObjectBounds[4] - o3di->MyObj->ObjectBounds[5]) / 2.0);
			for (i = 0; i < 3; i++)
				{
				// grh modified coords
				//geo[i] = ObjectList->Geographic[i];
				geo[i] = ObjectList->ExportXYZ[i];
				//rot[i] = ObjectList->Euler[i];
				scale[i] = ObjectList->Scale[i];
				//trans[i] = (float)o3di->Translation[i];
				} // for
			// convert geographic position to meters & our repositioning
			// grh modified coords
			//dx = (float)((-geo[0] - GeoCtrLon) * EARTHLATSCALE_METERS * LonScale);
			dx = (float)(geo[0] * Master->ExportRefData.ExportLonScale * scalefactor);
			//dy = (float)(geo[2] + boxy / 2.0);
			dy = (float)((Master->ExportRefData.RefElev + geo[2] - zmin) * scalefactor);
			dz = (float)(-geo[1] * Master->ExportRefData.ExportLatScale * scalefactor);
			dx += (FourCorners[0][0] + FourCorners[3][0]) * 0.5f;
			dz += (FourCorners[0][1] + FourCorners[3][1]) * 0.5f;
			fprintf(fVRML, "\n# %s\n", Object3D->Name);
			fprintf(fVRML, "Transform {\n");
			QuaternionToAxisAngle(AxisAngle, ObjectList->Quaternion);
			AxisAngle[3] *= PiOver180;
			fprintf(fVRML, " rotation %f %f %f %f\n", AxisAngle[0], -AxisAngle[1], AxisAngle[2], -AxisAngle[3]);
			/***
			// negation of rotation terms switches from left handed to right handed notation
			if (rot[2] != 0.0f)
				fprintf(fVRML, " rotation 0.0 0.0 1.0 %f\n", -rot[2]);	// bank    = z-axis
			if (rot[0] != 0.0f)
				fprintf(fVRML, " rotation 1.0 0.0 0.0 %f\n", -rot[0]);	// pitch   = x-axis
			if (rot[1] != 0.0f)
				fprintf(fVRML, " rotation 0.0 1.0 0.0 %f\n", -rot[1]);	// heading = y-axis
			***/
			if ((scale[0] != 1.0f) && (scale[1] != 1.0f) && (scale[2] != 1.0f))
				fprintf(fVRML, " scale %f %f %f\n", scale[0], scale[1], scale[2]);
			fprintf(fVRML, " translation %f %f %f\n", dx, dy, dz);
			fprintf(fVRML, " children [\n");
			MatCt = 0;
			fprintf(fVRML, "  LOD {\n   range [ %f %f ]\n   level [\n    Group {\n     children [\n",
				Master->AnimPar[WCS_EFFECTS_SCENEEXPORTER_ANIMPAR_OBJECTDISTBOX].CurValue,
				Master->AnimPar[WCS_EFFECTS_SCENEEXPORTER_ANIMPAR_OBJECTDISTVANISH].CurValue);
			do
				{
				fprintf(fVRML, "      # %s\n", Object3D->NameTable[MatCt].Name);
				fprintf(fVRML, "      Shape {\n");
				fprintf(fVRML, "       appearance Appearance {\n");
				ProcessMatTexture(MatCt, fVRML, Object3D);
				if (Object3D->VertexUVWAvailable)
					{
					UVMap = &Object3D->UVWTable[0];
					if (Illuminate3D)
						{
						fprintf(fVRML, "        material Material {\n");
						fprintf(fVRML, "         diffuseColor 1.0 1.0 1.0\n");
						fprintf(fVRML, "         specularColor 1.0 1.0 1.0\n");
						fprintf(fVRML, "        }\n");
						} // if
					} // if
				else
					{
					fprintf(fVRML, "        material Material {\n");
					fprintf(fVRML, "         diffuseColor %f %f %f\n", (float)Object3D->NameTable[MatCt].Mat->DiffuseColor.CurValue[0],
						(float)Object3D->NameTable[MatCt].Mat->DiffuseColor.CurValue[1], (float)Object3D->NameTable[MatCt].Mat->DiffuseColor.CurValue[2]);
					fprintf(fVRML, "         specularColor %f %f %f\n", (float)Object3D->NameTable[MatCt].Mat->SpecularColor.CurValue[0],
						(float)Object3D->NameTable[MatCt].Mat->SpecularColor.CurValue[1], (float)Object3D->NameTable[MatCt].Mat->SpecularColor.CurValue[2]);
					fprintf(fVRML, "        }\n");
					} // else
				fprintf(fVRML, "       }\n");
				//fprintf(fVRML, "   geometry Box\n   {\n    size %f %f %f\n", boxx, boxy, boxz);

				if (DidCoords)
					fprintf(fVRML, "       geometry IndexedFaceSet {\n        coord USE COORD%d\n", CoordsCount);
				else
					{
					DidCoords = 1;
					CoordsCount++;
					fprintf(fVRML, "       geometry IndexedFaceSet {\n        coord DEF COORD%d Coordinate {\n         point [\n", CoordsCount);
					for (VertCt = 0; VertCt < Object3D->NumVertices; VertCt++)
						{
						if ((VertCt % 5) != 0)
							fprintf(fVRML, ", ");
						// VtxData is an array of x,y,z triplets, careful of order
						x = Object3D->Vertices[VertCt].xyz[0] * scalefactor;
						y = Object3D->Vertices[VertCt].xyz[1] * scalefactor;
						z = Object3D->Vertices[VertCt].xyz[2] * scalefactor;
						fprintf(fVRML, "%f %f %f", (float)(x), (float)(y), (float)(-z));
						if ((VertCt % 5) == 4)
							fprintf(fVRML, "\n");
						} // for VertCt
					fprintf(fVRML, "\n         ]\n        }\n");
					} // else
				fprintf(fVRML, "        coordIndex [\n");
				for (PolyCt = 0; PolyCt < Object3D->NumPolys; PolyCt++)
					{
					if (Object3D->Polygons[PolyCt].Material == MatCt)
						{
						fprintf(fVRML, "         ");
						for (long i = 0; i < Object3D->Polygons[PolyCt].NumVerts; i++)
							fprintf(fVRML, "%d ", Object3D->Polygons[PolyCt].VertRef[i]);
						fprintf(fVRML, "-1\n");
						} // if
					} // for PolyCt
				fprintf(fVRML, "        ]\n");
				if (UVMap)
					{
					float u, v;
					fprintf(fVRML, "        texCoord TextureCoordinate {\n     point [\n");
					for (VertCt = 0; VertCt < Object3D->NumVertices; VertCt++)
						{
						if (UVMap->CoordsValid[VertCt])
							{
							u = UVMap->CoordsArray[0][VertCt];
							v = UVMap->CoordsArray[1][VertCt];
							} // if CoordsValid
						else
							u = v = 0.0f;
						fprintf(fVRML, "          %f %f\n", u, v);
						} // for VertCt
					fprintf(fVRML, "         ]\n        }\n");
					} // if UVMap
				fprintf(fVRML, "        solid FALSE\n       }\n      } # End: %s\n", Object3D->NameTable[MatCt].Name);
				MatCt++;
				} while (MatCt < Object3D->NumMaterials);
			fprintf(fVRML, "    ]\n   }\n");
			fprintf(fVRML, "    # Box node\n");
			fprintf(fVRML, "    Group {\n     children [\n      Transform {\n       translation 0.0 %f 0.0\n", boxy / 2.0f);
			fprintf(fVRML, "       children [\n");
			fprintf(fVRML, "        Shape {\n");
			fprintf(fVRML, "         appearance Appearance {\n");
			fprintf(fVRML, "          material Material {\n");
			fprintf(fVRML, "           diffuseColor %f %f %f\n", (float)Object3D->NameTable[0].Mat->DiffuseColor.CurValue[0],
				(float)Object3D->NameTable[0].Mat->DiffuseColor.CurValue[1], (float)Object3D->NameTable[0].Mat->DiffuseColor.CurValue[2]);
			fprintf(fVRML, "           specularColor %f %f %f\n", (float)Object3D->NameTable[0].Mat->SpecularColor.CurValue[0],
				(float)Object3D->NameTable[0].Mat->SpecularColor.CurValue[1], (float)Object3D->NameTable[0].Mat->SpecularColor.CurValue[2]);
			fprintf(fVRML, "         }\n");
			fprintf(fVRML, "        }\n");
			fprintf(fVRML, "       geometry Box { size %f %f %f } } ] } ] }\n", boxx, boxy, boxz);
			fprintf(fVRML, "    # Vanish node\n");
			fprintf(fVRML, "    Group { children [ ] }\n");
			fprintf(fVRML, "   ]\n  } # End LOD\n");
			fprintf(fVRML, " ]\n} # End: %s\n", Object3D->Name);

SkipObject:
			ObjectList = ObjectList->Next;
			} // while ObjectList
		} // if 3D objects

	// Vectors
	if (Master->ExportVectors && Master->VecInstanceList)
		{
		double vLat, vLon;
		float vElev;
		long i, n;
		Joe *CurJoe;
		VectorExportItem *VEI;
		VectorPoint *vert;

		for (n = 0; n < Master->NumVecInstances; n++)
			{
			VEI = &Master->VecInstanceList[n];
			CurJoe = VEI->MyJoe;
			// start the shape & set the color
			fprintf(fVRML, "\nShape {\n appearance Appearance {\n  material Material {\n");
			fprintf(fVRML, "   diffuseColor %f %f %f\n", CurJoe->Red() / 255.0f, CurJoe->Green() / 255.0f, CurJoe->Blue() / 255.0f);
			fprintf(fVRML, "  }\n }\n");
			// now the geometry
			fprintf(fVRML, " geometry IndexedLineSet {\n  coord Coordinate {\n   point [");
			vert = VEI->Points;
			i = 0;
			while (vert)
				{
				vLat = vert->Latitude * Master->ExportRefData.ExportLatScale;
				vLon = vert->Longitude * Master->ExportRefData.ExportLonScale;
				vElev = vert->Elevation;
				// print no more than 4 triplets per line
				if ((i % 4) == 0)
					fprintf(fVRML, "\n    %f %f %f", (float)vLon, vElev, -(float)vLat);
				else
					fprintf(fVRML, ", %f %f %f", (float)vLon, vElev, -(float)vLat);
				i++;
				vert = vert->Next;
				} // while vert
			fprintf(fVRML, "\n   ]\n  }\n");
			fprintf(fVRML, "  coordIndex [\n   ");
			for (i = 0; i < VEI->NumPoints; i++)
				fprintf(fVRML, "%d ", i);
			fprintf(fVRML, "\n  ]\n }\n}\n");
			} // while VEI

		} // if Vectors

	if (Master->ZipItUp)
		{
		gzFile gz;
		size_t bytes;
		char buffer[1024];

		if (X3D)
			SceneOutput.GetFramePathAndName(TempFullPath, ".x3dvz", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		else
			SceneOutput.GetFramePathAndName(TempFullPath, ".wrz", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		strcpy(TempFullPath, GlobalApp->MainProj->MungPath(TempFullPath));
		if (gz = gzopen(TempFullPath, "wb9"))
			{
			rewind(fVRML);

			while (bytes = fread(buffer, 1, 1024, fVRML))
				gzwrite(gz, buffer, (unsigned int)bytes);

			if (gzclose(gz) == Z_OK)	// remove the original file if compression was successful
				{
				fclose(fVRML);
				SceneOutput.GetFramePathAndName(TempFullPath, ".wrl", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
				strcpy(TempFullPath, GlobalApp->MainProj->MungPath(TempFullPath));
				remove(TempFullPath);
				} // if Z_OK
			} // if gz
		} // if gzipping

	} // if
else
	Success = 0;

Cleanup:

if (TW)
	{
	delete TW;
	TW = NULL;
	} // if

if (fVRML)
	{
	fclose(fVRML);
	fVRML = NULL;
	} // if

if (fRaw)
	{
	fclose(fRaw);
	fRaw = NULL;
	} // if

if (RJob)
	{
	delete RJob;
	RJob = NULL;
	} // if

if (Line2)
	{
	AppMem_Free(Line2, LineSize);
	Line2 = NULL;
	} // if

if (Line1)
	{
	AppMem_Free(Line1, LineSize);
	Line1 = NULL;
	} // if

// remove terrain temp file(s)
FileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
if (Tiles)
	{
	RawTerrainFile = NULL;
	while (RawTerrainFile = (*FileNamesCreated)->FindNextNameOfType(FileType, RawTerrainFile))
		{
		strmfp(FullFileName, OutputFilePath, RawTerrainFile);
		PROJ_remove(FullFileName);
		} // while
	} // if Tiles
else
	{
	RawTerrainFile = (*FileNamesCreated)->FindNameOfType(FileType);
	strmfp(FullFileName, OutputFilePath, RawTerrainFile);
	PROJ_remove(FullFileName);
	} // else Tiles

// must do this as it's not dynamically allocated and RealtimeFoliageIndex
// destructor will blow chunks if we don't
Index.CellDat = NULL;

return (Success);

} // ExportFormatVRMLSTL::PackageExport

/*===========================================================================*/

ExportFormatVRMLSTL::~ExportFormatVRMLSTL()
{

} // ExportFormatVRMLSTL::~ExportFormatVRMLSTL

/*===========================================================================*/

// TW->EmitTerrain(lod_tilesizex, lod_tilesizey, fRaw, fVRML, ElevAdjust, 0.0f, 0, 0);
int ExportFormatVRMLSTL::Gen_IFS_Elevs(FILE *fRaw, FILE *fVRML, float ElevAdjust, long xdim, long ydim)
{
float elev, xpos, zpos;
int Success = 1;
long vert1, vert2, vertnum, x, z;

/***

Viewed from Above:

0 --- 1 --- 2 ... (vert1)
|\    |\    |
|  \  |  \  |
|    \|    \|
* --- * --- * ... (vert2)

***/

fprintf(fVRML, "      geometry IndexedFaceSet {\n");
fprintf(fVRML, "       coord Coordinate {\n");
fprintf(fVRML, "        point [");
rewind(fRaw);
zpos = 0.0f;
for (z = 0; z < ydim; z++, zpos += ZStep)
	{
	xpos = 0.0f;
	for (x = 0; x < xdim; x++, xpos += XStep)
		{
		fread(&elev, sizeof(float), 1, fRaw);
		elev = (float)((elev + ElevAdjust) * ScaleFactor);
		if (x != 0)
			fprintf(fVRML, ", %f %f %f", xpos, elev, zpos);
		else
			fprintf(fVRML, "\n%f %f %f", xpos, elev, zpos);
		} // for x
	} // for y
fprintf(fVRML, "\n        ]\n      }\n");
fprintf(fVRML, "      coordIndex [");
for (z = 0; z < (ydim - 1); z++)
	{
	vertnum = z * xdim;
	for (x = 0, vert1 = vertnum, vert2 = vert1 + xdim; x < (xdim - 1); x++, vert1++, vert2++)
		{
		// lower triangle
		fprintf(fVRML, "\n   %d %d %d -1", vert1, vert2, vert2 + 1);
		// upper triangle
		fprintf(fVRML, "\n   %d %d %d -1", vert2 + 1, vert1 + 1, vert1);
		} // for x
	} // for z

return Success;

} // ExportFormatVRMLSTL::Gen_IFS_Elevs

/*===========================================================================*/
