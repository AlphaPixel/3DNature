// ExportFormatWW.cpp
// Code module for WorldWind export code
// Created from ExportFormatGIS.cpp on 7/6/06 by CXH
// Created on 12/16/04 by FPW2
// Copyright 2004 3D Nature, LLC. All rights reserved.

#include "stdafx.h"
#include "ExportFormat.h"
#include "EffectsLib.h"
#include "ExportControlGUI.h"
#include "IncludeExcludeList.h"
#include "Raster.h"
#include "ImageOutputEvent.h"
#include "Project.h"
#include "Requester.h"
#include "AppMem.h"
#include "RasterResampler.h"
#include "Log.h"
#include "SceneExportGUI.h"
#include "SXExtension.h"
#include "Security.h"
#include "DBEditGUI.h"
#include "Shapefiles.h"
#include "DirectX_Support.h"
#include "RasterResampler.h"
#include "AppMem.h"

extern long WW_level;

// Generated by BreakPoint Software's Hex Workshop v4.20
//   http://www.hexworkshop.com
//   http://www.bpsoft.com
//
//  Source File: GIS_Exporter_Foliage_Template.dbf
//         Time: 11/9/2005 1:02 PM
// Orig. Offset: 0 / 0x00000000
//       Length: 161 / 0x000000A1 (bytes)
extern unsigned char dbfData[161]; // from ExportFormatGIS

extern bool GIS_Name_Warned;
static char msgWW[] = "WorldWind Exporter";

ExportFormatWW::ExportFormatWW(SceneExporter *MasterSource, Project *ProjectSource, EffectsLib *EffectsSource, Database *DBSource, ImageLib *ImageSource)
: ExportFormat(MasterSource, ProjectSource, EffectsSource, DBSource, ImageSource)
{

fPaF.SetPath(Master->OutPath.Path);
fPaF.SetName("Foliage");

pPaF.SetPath(Master->OutPath.Path);
pPaF.SetName("Point");

vPaF.SetPath(Master->OutPath.Path);
vPaF.SetName("Vector");

} // ExportFormatWW::ExportFormatWW

/*===========================================================================*/

ExportFormatWW::~ExportFormatWW()
{

} // ExportFormatWW::~ExportFormatWW

/*===========================================================================*/

// remove all temp files
void ExportFormatWW::Cleanup(const char *outputFilePath, NameList **fileNamesCreated)
{
const char *cleanupFileName;
long fileType;
char fullFileName[512];

// remove foliage temp files
fileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
if (cleanupFileName = (*fileNamesCreated)->FindNameOfType(fileType))
	{
	strmfp(fullFileName, outputFilePath, cleanupFileName);
	PROJ_remove(fullFileName);

	fileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
	if (cleanupFileName = (*fileNamesCreated)->FindNameOfType(fileType))
		{
		strmfp(fullFileName, outputFilePath, cleanupFileName);
		PROJ_remove(fullFileName);
		} // if
	} // if

// remove terrain temp file
if (Master->ExportTerrain)
	{
	fileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	cleanupFileName = (*fileNamesCreated)->FindNameOfType(fileType);
	strmfp(fullFileName, outputFilePath, cleanupFileName);
	PROJ_remove(fullFileName);
	} // if

} // ExportFormatWW::Cleanup

/*===========================================================================*/

int ExportFormatWW::ExportTerrain(NameList **fileNamesCreated)
{
FILE *fOut = NULL, *fRaw = NULL;
RasterResampler *resamp = NULL;
const char *rawTerrainFile;
long curLevel = WW_level;
long levels2do = Master->LODLevels;
long edgeTiles = 1;
int success = 0;
char resampledFileName[512], tileFileName[512];

if (resamp = new FloatRasterResampler())
	{
	long edgeRes, fileType, totalRes = Master->OrigDEMResX * Master->OrigDEMResY, xTile, yTile;
	PathAndFile daBIL;
	char scratch[16], tempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];

	resamp->SetNull(-9999.0f);
	fileType = WCS_EXPORTCONTROL_FILETYPE_FINALTERRAIN;
	rawTerrainFile = (*fileNamesCreated)->FindNameOfType(fileType);

	edgeRes = Master->DEMResX;
	do
		{
		double edgeSize;

		// compute size in degrees of each tile
		edgeSize = pow(2.0, (double)-curLevel);

		// set path & create directory for the layer number
		strcpy(tempFullPath, Master->OutPath.GetPath());
		sprintf(scratch, "/%d", curLevel);
		strcat(tempFullPath, scratch);
		daBIL.SetPath(tempFullPath);
		PROJ_mkdir(tempFullPath);

		for (yTile = 0; yTile < edgeTiles; yTile++)
			{
			for (xTile = 0; xTile < edgeTiles; xTile++)
				{
				double temp1, temp2;
				long WW_row, WW_col;

				// Crop a tile from the full res data
				ExtractTileElevs(rawTerrainFile, Master->DEMResX, edgeTiles, xTile, yTile);

				// Now for some FUN stuff.  Convert our tile numbers into World Wind's Row & Column system.
				temp1 = Master->GeoReg.AnimPar[1].CurValue + (edgeTiles - yTile - 1) * edgeSize;	// south lat for this tile
				temp2 = (temp1 + 90.0) / edgeSize;	// NS binning
				WW_row = quickftol(temp2);	// integer portion contains the bin number
				temp1 = -Master->GeoReg.AnimPar[2].CurValue + xTile * edgeSize;	// west lon for this tile
				temp2 = (temp1 + 180.0) / edgeSize;	// WE binning
				WW_col = quickftol(temp2);	// integer portion contains the bin number

				// set path & create directory for the row number
				strcpy(tempFullPath, Master->OutPath.GetPath());
				sprintf(scratch, "/%d/%04d", curLevel, WW_row);
				strcat(tempFullPath, scratch);
				daBIL.SetPath(tempFullPath);
				PROJ_mkdir(tempFullPath);

				// the name of the current WW tile
				sprintf(tempFullPath, "%04d_%04d", WW_row, WW_col);
				daBIL.SetName(tempFullPath);
				daBIL.GetFramePathAndName(tempFullPath, ".bil", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
				fOut = PROJ_fopen(tempFullPath, "wb");

				if (fOut)
					{
					//Master->RBounds.DeriveTileCoords(Master->DEMResY, Master->DEMResX, edgeTiles, edgeTiles, yTile, xTile, 0);

					strmfp(tileFileName, Master->OutPath.GetPath(), "lod_tmp.raw");
					strmfp(resampledFileName, Master->OutPath.GetPath(), "resampled.raw");
					if (resamp->Resample(tileFileName, resampledFileName, edgeRes, edgeRes, Master->OrigDEMResY, Master->OrigDEMResX))
					//if (resamp->ResampleTile(rawTerrainFile, resampledFileName, Master->DEMResY, Master->DEMResX,
					//	Master->OrigDEMResY, Master->OrigDEMResX, edgeTiles, edgeTiles, yTile, xTile, 0))
						{
						if (fRaw = PROJ_fopen(resampledFileName, "rb"))
							{
							for (long i = 0; i < totalRes; i++)
								{
								float felev;
								short  selev;

								fread(&felev, sizeof(float), 1, fRaw);
								selev = (short)felev;
								fwrite(&selev, sizeof(short), 1, fOut);
								} // for
							fclose(fOut);
							fclose(fRaw);
							} // if
						} // if
					PROJ_remove(resampledFileName);
					PROJ_remove(tileFileName);
					} // if fOut
				} // for xTile
			} // for yTile
		edgeRes /= 2;
		edgeTiles *= 2;
		curLevel++;
		levels2do--;
		} while (levels2do);

	success = 1;
	} // if

return success;

} // ExportFormatWW::ExportTerrain

/*===========================================================================*/

int ExportFormatWW::ExtractTileElevs(const char *rawTerrainFile, long fullEdgeRes, long edgeTiles, long xTile, long yTile)
{
FILE *fIn = NULL, *fOut = NULL;
//float *buffer = NULL;
int success = 0;
long frcs = sizeof(float);	// full res cell size
long tileEdgeRes = fullEdgeRes / edgeTiles;
char tempFileName[512];

strmfp(tempFileName, Master->OutPath.GetPath(), "lod_tmp.raw");
//if ((fIn = PROJ_fopen(rawTerrainFile, "rb")) && (fOut = PROJ_fopen(tempFileName, "wb")) && (buffer = (float *)AppMem_Alloc(tileEdgeRes * frcs, 0)))
if ((fIn = PROJ_fopen(rawTerrainFile, "rb")) && (fOut = PROJ_fopen(tempFileName, "wb")))
		success = 1;

if (success)
	{
	long curX, curY, xStart, yStart;

	xStart = tileEdgeRes * xTile;
	yStart = tileEdgeRes * yTile;
	for (curY = 0; curY < tileEdgeRes; curY++)
		{
		fseek(fIn, (curY + yStart) * fullEdgeRes * frcs + xStart * frcs, SEEK_SET);
//		fread(&buffer, (size_t)frcs, (size_t)tileEdgeRes, fIn);
//		fwrite(&buffer, (size_t)frcs, (size_t)tileEdgeRes, fOut);
		for (curX = 0; curX < tileEdgeRes; curX++)
			{
			float elev;

			fread(&elev, frcs, 1, fIn);
			fwrite(&elev, frcs, 1, fOut);
			} // for curX
		} // for curY
	} // if

//if (buffer)
//	AppMem_Free(buffer, tileEdgeRes * frcs);

if (fOut)
	fclose(fOut);

if (fIn)
	fclose(fIn);

return(success);

} // ExportFormatWW::ExtractTileElevs

/*===========================================================================*/
int ExportFormatWW::PackageExport(NameList **FileNamesCreated)
{
FILE *fOut = NULL;
int Success = 1;
long FileType;
//long PatternIndex = 0;
PathAndFile PaF;
char TempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];
const char *OutputFilePath;
class OF_ColorPalette CP;
class OF_VertexPalette VP;
JoeApproveHook LocalJoeApproveHook;
//char NewPAFName[512], OldPAFName[512];
const char *IndexFileName;

if (GlobalApp->Sentinal->CheckAuthFieldSX2() == 0)
	return 0;

GIS_Name_Warned = false;	// init shapefile name warning flag

// The directory where all the files should be created is:
OutputFilePath = Master->OutPath.GetPath();

if (Master->ExportTerrain)
	ExportTerrain(FileNamesCreated);

#ifdef GORILLA
if (Master->ExportTerrain)
	{
	PaF.SetPath((char *)Master->OutPath.GetPath());
	PaF.SetName((char *)Master->OutPath.GetName());
	PaF.GetFramePathAndName(TempFullPath, ".raw", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
	if (fGrid = PROJ_fopen(TempFullPath, "rb"))
		{
		// the RAW DEM is renamed & becomes the ESRI DEM
		fclose(fGrid);
		strcpy(OldPAFName, TempFullPath);
		PaF.GetFramePathAndName(NewPAFName, ".flt", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		if (fOut = PROJ_fopen(NewPAFName, "r"))
			{
			fclose(fOut);
			PROJ_remove(NewPAFName);
			}; // if
		PROJ_rename(OldPAFName, NewPAFName);
		// create the header for the DEM
		PaF.GetFramePathAndName(TempFullPath, ".hdr", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		if (fOut = PROJ_fopen(TempFullPath, "w"))
			{
			//double cellsize;

			Master->RBounds.DeriveCoords(Master->DEMResY, Master->DEMResX);
			fprintf(fOut, "ncols         %d\n", Master->DEMResX);
			fprintf(fOut, "nrows         %d\n", Master->DEMResY);
			//*** RBounds & it's GeoReg & values is different than GeoReg, so we can't do this the "easy" way right now - fixed?
			fprintf(fOut, "xllcorner     %f\n", Master->RBounds.ULcorner.x);
			fprintf(fOut, "yllcorner     %f\n", Master->RBounds.LRcorner.y);
			if (fabs((Master->RBounds.CellSizeX - Master->RBounds.CellSizeY)) < 0.00001)	// if they're equal
				{
				fprintf(fOut, "cellsize      %f\n", Master->RBounds.CellSizeX);
				} // if
			else
				{
				// older software may not support these fields - user should ensure they're equal if it's a problem for them
				fprintf(fOut, "xdim      %f\n", Master->RBounds.CellSizeX);
				fprintf(fOut, "ydim      %f\n", Master->RBounds.CellSizeY);
				} // else
			//***/
			/*** workaround not needed now
			cellsize = (Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_NORTH].CurValue - Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_SOUTH].CurValue) /
				(Master->DEMResY - 1);
			fprintf(fOut, "xllcorner     %f\n", Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_WEST].CurValue - (cellsize * 0.5));
			fprintf(fOut, "yllcorner     %f\n", Master->GeoReg.AnimPar[WCS_EFFECTS_GEOREGISTER_ANIMPAR_SOUTH].CurValue - (cellsize * 0.5));
			fprintf(fOut, "cellsize      %f\n", cellsize);
			***/
			// CellSizeY
			//fprintf(fOut, "NODATA_value\n");
			fprintf(fOut, "byteorder     LSBFIRST\n");
			fclose(fOut);
			} // if fOut
		PaF.GetFramePathAndName(TempFullPath, ".prj", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
		if (Master->RBounds.MyCoords && (fOut = PROJ_fopen(TempFullPath, "w")))
			{
			Master->RBounds.MyCoords->SaveToArcPrj(fOut);
			fclose(fOut);
			} // if fOut
		} // if fGrid
	else
		Success = 0;
	} // if ExportTerrain
#endif // GORILLA

Master->RBounds.DeriveCoords(Master->TexResX, Master->TexResY);
FileType = WCS_EXPORTCONTROL_FILETYPE_TEX1;
if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	strcpy(TempFullPath, IndexFileName);
	StripExtension(TempFullPath);
	strcat(TempFullPath, ".tfw");
	if (fOut = PROJ_fopen(TempFullPath, "w"))
		{
		fprintf(fOut, "%f\n", Master->RBounds.CellSizeX);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", -Master->RBounds.CellSizeY);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.x);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.y);
		fclose(fOut);
		} // if fOut
	} // if Tex1

FileType = WCS_EXPORTCONTROL_FILETYPE_TEX2;
if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	strcpy(TempFullPath, IndexFileName);
	StripExtension(TempFullPath);
	strcat(TempFullPath, ".tfw");
	if (fOut = PROJ_fopen(TempFullPath, "w"))
		{
		fprintf(fOut, "%f\n", Master->RBounds.CellSizeX);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", 0.0);
		fprintf(fOut, "%f\n", -Master->RBounds.CellSizeY);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.x);
		fprintf(fOut, "%f\n", Master->RBounds.ULcenter.y);
		fclose(fOut);
		} // if fOut
	} // if Tex2

if (Success && Master->Export3DObjects)
	{
	Success = Process3DObjects(FileNamesCreated, OutputFilePath);
	} // if Export3DObjects

if (Success && Master->ExportVectors)
	{
	FILE *ShapeXML = NULL;
	PathAndFile ShapeXMLPAF;
	int FlipLon = 1;

	ShapeXMLPAF.SetPath(vPaF.GetPath());
	ShapeXMLPAF.SetName((char *)Master->OutPath.GetName());

	ShapeXMLPAF.GetFramePathAndName(TempFullPath, ".xml", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
	if(ShapeXML = PROJ_fopen(TempFullPath, "w"))
		{
/*
<?xml version="1.0" encoding="UTF-8"?>
<LayerSet Name="ShapeFile" ShowOnlyOneLayer="false" ShowAtStartup="true">
  <ShapeFileDescriptor ShowAtStartup="true">
    <Name>Vector2D</Name>
    <ShapeFilePath>C:\Data\WCS\WCSProjects\Fairplay\PowerplantWW\Vector2D.shp</ShapeFilePath>
    <LevelZeroTileSize>1.0</LevelZeroTileSize>
    <MaxAltitude>100000</MaxAltitude>
    <MinAltitude>10</MinAltitude>
    <PolygonFill>false</PolygonFill>
    <OutlinePolygons>true</OutlinePolygons>
    <ScaleColorsToData>false</ScaleColorsToData>
    <LineColor>
      <Red>255</Red>
      <Green>0</Green>
      <Blue>0</Blue>
    </LineColor>
    <LineWidth>1.0</LineWidth>
  </ShapeFileDescriptor>
</LayerSet>
*/
		fprintf(ShapeXML, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		fprintf(ShapeXML, "<LayerSet Name=\"%s\" ShowOnlyOneLayer=\"false\" ShowAtStartup=\"true\">\n", Master->OutPath.GetName());

		LocalJoeApproveHook.ObjectThis = GlobalApp->AppDB->StaticRoot;
		LocalJoeApproveHook.Approve = DBEditJoeApprove;
		LocalJoeApproveHook.ExportDEMsAs = WCS_DBEXPORT_DEMSAS_POLYFACEMESH;	// This field isn't relevant to our export
		LocalJoeApproveHook.ExportObjects = WCS_DBEXPORT_OBJECTS_RENDERENABLED;

		// Export vectors to Shapefiles
		// DBF consists of a Vector Name field, plus columns for any attribute fields
		LocalJoeApproveHook.ExportClasses = WCS_DBEXPORT_CLASS_VECTORS | WCS_DBEXPORT_CLASS_CONTROLPTS;
		Success = GlobalApp->AppDB->ExportShape(GlobalApp->MainProj, &LocalJoeApproveHook, Master->RBounds.MyCoords, 1.0, 1.0, FlipLon,
			1, 1, 0.0, &Master->RBounds, 0, pPaF.Path, pPaF.Name);	// points only

		if (Success)
			{
			pPaF.GetFramePathAndName(TempFullPath, ".shp", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
			fprintf(ShapeXML, "  <ShapeFileDescriptor ShowAtStartup=\"true\">\n");
			fprintf(ShapeXML, "    <Name>Points</Name>\n");
			fprintf(ShapeXML, "    <ShapeFilePath>%s</ShapeFilePath>\n", GlobalApp->MainProj->MungPath(TempFullPath));
			fprintf(ShapeXML, "    <LevelZeroTileSize>1.0</LevelZeroTileSize>\n");
			fprintf(ShapeXML, "    <MaxAltitude>100000</MaxAltitude>\n");
			fprintf(ShapeXML, "    <MinAltitude>10</MinAltitude>\n");
			fprintf(ShapeXML, "    <PolygonFill>false</PolygonFill>\n");
			fprintf(ShapeXML, "    <OutlinePolygons>true</OutlinePolygons>\n");
			fprintf(ShapeXML, "    <ScaleColorsToData>false</ScaleColorsToData>\n");
			fprintf(ShapeXML, "    <LineColor>\n");
			fprintf(ShapeXML, "      <Red>255</Red>\n");
			fprintf(ShapeXML, "      <Green>0</Green>\n");
			fprintf(ShapeXML, "      <Blue>0</Blue>\n");
			fprintf(ShapeXML, "    </LineColor>\n");
			fprintf(ShapeXML, "    <LineWidth>1.0</LineWidth>\n");
			fprintf(ShapeXML, "  </ShapeFileDescriptor>\n");
			} // if


		if (Success)
			{
			LocalJoeApproveHook.ExportClasses = WCS_DBEXPORT_CLASS_VECTORS;
			Success = GlobalApp->AppDB->ExportShape(GlobalApp->MainProj, &LocalJoeApproveHook, Master->RBounds.MyCoords, 1.0, 1.0, FlipLon,
				1, 1, 0.0, &Master->RBounds, 1, vPaF.Path, vPaF.Name);	// vectors only
			if(Success)
				{
				vPaF.GetFramePathAndName(TempFullPath, ".shp", 0, WCS_PATHANDFILE_PATH_PLUS_NAME_LEN, 0);
				fprintf(ShapeXML, "  <ShapeFileDescriptor ShowAtStartup=\"true\">\n");
				fprintf(ShapeXML, "    <Name>Lines</Name>\n");
				fprintf(ShapeXML, "    <ShapeFilePath>%s</ShapeFilePath>\n", GlobalApp->MainProj->MungPath(TempFullPath));
				fprintf(ShapeXML, "    <LevelZeroTileSize>1.0</LevelZeroTileSize>\n");
				fprintf(ShapeXML, "    <MaxAltitude>100000</MaxAltitude>\n");
				fprintf(ShapeXML, "    <MinAltitude>10</MinAltitude>\n");
				fprintf(ShapeXML, "    <PolygonFill>false</PolygonFill>\n");
				fprintf(ShapeXML, "    <OutlinePolygons>true</OutlinePolygons>\n");
				fprintf(ShapeXML, "    <ScaleColorsToData>false</ScaleColorsToData>\n");
				fprintf(ShapeXML, "    <LineColor>\n");
				fprintf(ShapeXML, "      <Red>255</Red>\n");
				fprintf(ShapeXML, "      <Green>0</Green>\n");
				fprintf(ShapeXML, "      <Blue>0</Blue>\n");
				fprintf(ShapeXML, "    </LineColor>\n");
				fprintf(ShapeXML, "    <LineWidth>1.0</LineWidth>\n");
				fprintf(ShapeXML, "  </ShapeFileDescriptor>\n");
				} // if
			} // if
		LocalJoeApproveHook.ObjectThis = NULL;

		fprintf(ShapeXML, "</LayerSet>\n");
		fclose(ShapeXML);
		} // if


	} // if ExportVectors


if (Success && Master->ExportFoliage)
	Success = ProcessFoliageList(FileNamesCreated, OutputFilePath);

Cleanup(OutputFilePath, FileNamesCreated);

return (Success);

} // ExportFormatWW::PackageExport

/*===========================================================================*/

int ExportFormatWW::Process3DObjects(NameList **FileNamesCreated, const char *OutputFilePath)
{
Object3DInstance *curInstance = Master->ObjectInstanceList;
Object3DEffect *curObj;
int success = 1;
DX_model dx(Master);

while (success && curInstance)
	{
	curObj = curInstance->MyObj;
	if (curObj && curInstance->IsBounded(Master->FetchRBounds()) &&
		((curObj->Vertices && curObj->Polygons && curObj->NameTable) || curObj->OpenInputFile(NULL, FALSE, FALSE, FALSE)))
		success = (dx.ExportModel(curInstance) >= 0);

	curInstance = curInstance->Next;
	} // while

return success;

} // ExportFormatWW::Process3DObjects

/*===========================================================================*/

int ExportFormatWW::ProcessFoliageList(NameList **FileNamesCreated, const char *OutputFilePath)
{
//double BBot, BLeft, BRight, BTop;
double ExportX, ExportY;
double ref_x, ref_y, ref_z;
FILE *ffile;
//static long TreeNum = 0;	// for labeling tree LOD's
long DatPt, FileType;
//long WriteFol = 0;
//short *XlateTable = NULL;
int Success = 1;
const char *IndexFileName, *DataFileName;
RealtimeFoliageIndex Index;
RealtimeFoliageCellData RFCD;
RealtimeFoliageData FolData;
//char TempFullPath[WCS_PATHANDFILE_PATH_PLUS_NAME_LEN];
//char fName[WCS_PATHANDFILE_PATH_LEN + WCS_PATHANDFILE_NAME_LEN];
char FileName[512];
char TestFileVersion;

ref_x = Master->ExportRefData.ExportRefLon;
ref_y = Master->ExportRefData.ExportRefLat;
ref_z = Master->ExportRefData.RefElev;

fPaF.SetPath((char *)Master->OutPath.GetPath());

// files may not exist. If they don't then user must not have chosen foliage export features
FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILEIDX;
if (IndexFileName = (*FileNamesCreated)->FindNameOfType(FileType))
	{
	FileType = WCS_EXPORTCONTROL_FILETYPE_FOLFILE;
	if (DataFileName = (*FileNamesCreated)->FindNameOfType(FileType))
		{
		// you've got the two file names that the Renderer wrote out.
		// combine them with the output file path to make a file that can be opened with PROJ_fopen()

		// find and open the index file
		strmfp(FileName, OutputFilePath, IndexFileName);
		if (ffile = PROJ_fopen(FileName, "rb"))
			{
			// read file descriptor, no need to keep it around unless you want to
			fgets(FileName, 256, ffile);
			// version
			fread((char *)&Index.FileVersion, sizeof(char), 1, ffile);
			// number of files
			fread((char *)&Index.NumCells, sizeof(long), 1, ffile);
			// reference XYZ
			fread((char *)&Index.RefXYZ[0], sizeof(double), 1, ffile);
			fread((char *)&Index.RefXYZ[1], sizeof(double), 1, ffile);
			fread((char *)&Index.RefXYZ[2], sizeof(double), 1, ffile);

			if (Index.NumCells > 0)
				{
				// only one cell data entry is provided
				if (Index.CellDat = &RFCD)
					{
					// file name
					fgets(Index.CellDat->FileName, 64, ffile);
					// center XYZ
					fread((char *)&Index.CellDat->CellXYZ[0], sizeof(double), 1, ffile);
					fread((char *)&Index.CellDat->CellXYZ[1], sizeof(double), 1, ffile);
					fread((char *)&Index.CellDat->CellXYZ[2], sizeof(double), 1, ffile);
					// half cube cell dimension
					fread((char *)&Index.CellDat->CellRad, sizeof(double), 1, ffile);
					// number of trees in file
					fread((char *)&Index.CellDat->DatCt, sizeof(long), 1, ffile);
					} // if
				} // if some cells to read
			fclose(ffile);

			if ((Index.NumCells > 0) && (Index.CellDat->DatCt > 0))
				{
				strmfp(FileName, OutputFilePath, DataFileName);
				if (ffile = PROJ_fopen(FileName, "rb"))
					{
					fgets(FileName, 64, ffile);
					// version
					fread((char *)&TestFileVersion, sizeof(char), 1, ffile);
					// Pointless version check -- we know we wrote it
					if (TestFileVersion == Index.FileVersion)
						{
						class Shapefile3D *Shape;
						FILE *fdBase;

						Shape = new Shapefile3D(SHP_PointZ);
						if (Shape)
							{
							Shape->Init((char *)fPaF.GetPath(), (char *)fPaF.GetName());
							fdBase = Shape->Get_dBase_Handle();
							if (fdBase)
								{
								fwrite(dbfData, 1, sizeof(dbfData), fdBase);	// write the Table File Header & Table File Descriptor
								// see if any foliage exists
								for (DatPt = 0; DatPt < Index.CellDat->DatCt; DatPt++)
									{
									if (FolData.ReadFoliageRecord(ffile, Index.FileVersion))
										{
										Raster *CurRast;
										long id;
										FoliagePreviewData PointData;
										// Don't touch these unless you change the dbfData!!!
										char ID_num[6];
										char ImageName[81];
										char Height[9];
										char ImageName2[81];

										FolData.InterpretFoliageRecord(NULL, GlobalApp->AppImages, &PointData);

										//if (FolData.BitInfo & WCS_REALTIME_FOLDAT_BITINFO_LABEL) // label
										//	printf("got it");

										if (Master->RBounds.IsGeographic)
											{
											ExportX = FolData.XYZ[0] + ref_x;
											ExportY = FolData.XYZ[1] + ref_y;
											} // if
										else
											{
											ExportX = FolData.XYZ[0] * Master->ExportRefData.ExportLonScale + ref_x;
											ExportY = FolData.XYZ[1] * Master->ExportRefData.ExportLatScale + ref_y;
											} // else
										Shape->SetX(ExportX);
										Shape->SetY(ExportY);
										Shape->SetZ(FolData.XYZ[2] * Master->ExportRefData.ElevScale + ref_z);
										Shape->WritePointZ();

										id = FolData.ElementID;

										memset(ID_num, 0x20, sizeof(ID_num));
										memset(ImageName, 0x20, sizeof(ImageName));
										memset(Height, 0x20, sizeof(Height));
										memset(ImageName2, 0x20, sizeof(ImageName2));
										if (CurRast = Images->FindByID(id))
											{
											long ndx;

											strncpy(ImageName, CurRast->GetUserName(), sizeof(ImageName));
											sprintf(ID_num, "%5d", FolData.ElementID);
											sprintf(Height, "%8.2f", PointData.Height);
											strncpy(ImageName2, CurRast->PAF.GetName(), sizeof(ImageName2));

											// strncpy zero filled our fields, but it's supposed to be filled with the space char
											ndx = sizeof(ImageName) - 1;
											do
												{
												ImageName[ndx] = 0x20;
												--ndx;
												}  while ((ndx > 0) && (ImageName[ndx] == 0));
											ndx = sizeof(ImageName2) - 1;
											do
												{
												ImageName2[ndx] = 0x20;
												--ndx;
												}  while ((ndx > 0) && (ImageName2[ndx] == 0));
											} // if
										fputc(0x20, fdBase);	// start a new record - indicate that it hasn't been deleted
										fwrite(ID_num, 1, sizeof(ID_num) - 1, fdBase);
										fwrite(ImageName, 1, sizeof(ImageName) - 1, fdBase);
										fwrite(Height, 1, sizeof(Height) - 1, fdBase);
										fwrite(ImageName2, 1, sizeof(ImageName2) - 1, fdBase);

										} // if
									} // for

								FILE *fPrj = NULL;
								strmfp(FileName, fPaF.GetPath(), fPaF.GetName());
								strcat(FileName, ".prj");
								if (Master->Coords && (fPrj = PROJ_fopen(FileName, "w")))
									{
									Master->Coords->SaveToArcPrj(fPrj);
									fclose(fPrj);
									} // if

								} // if fdBase
							else
								{
								char msg[512];

								sprintf(&msg[0], "Can't open %s\\%s.dbf", fPaF.GetPath(), fPaF.GetName());
								GlobalApp->StatusLog->PostError(WCS_LOG_SEVERITY_MSG, msg);
								Success = 0;
								} // else

							Shape->Wrapup();
							delete Shape;
							} // if Shape
						else
							Success = 0;

						} // if
					fclose(ffile);
					} // if
				} // if
			} // if
		} // if
	} // if

// must do this as it's not dynamically allocated and RealtimeFoliageIndex
// destructor will blow chunks if we don't
Index.CellDat = NULL;

return (Success);

} // ExportFormatWW::ProcessFoliageList

/*===========================================================================*/

int ExportFormatWW::SanityCheck(void)
{
long vWarn = 0;
int rVal = 0;
int Success = 1;

// see if shapefile name is spec compliant
if (vPaF.Name[0])
	{
	if (strlen(vPaF.GetName()) > 8)
		vWarn = 1;
	if (! isalnum((int)vPaF.Name[0]))
		vWarn = 1;
	for (long i = 0; i < 8; i++)
		{
		int ch = vPaF.Name[i];

		if (ch == 0)
			break;
		if (!(isalnum(ch) || (ch == '_') || (ch == '-')))
			vWarn = 1;
		} // for
	} // if vPAF.Name
else
	vWarn = TRUE;

if (vWarn)
	{
	if (UserMessageYN("Invalid Shapefile Name", "The Shapefile name for Vector export isn't fully spec compliant.\n\nDo you wish to fix it?"))
		{
		char str[256];
		// this function won't guarantee a valid string, but they've been warned...
		GetInputString("The base file name must be 8 characters or less in length. The first character must be a letter or digit. \
Any additional characters must be a number, digit, the dash (-) or the underscore (_)", "~`!@#$%^&*()+={}[]|\\:;\"\'<,>.\?/", str);
		vPaF.SetName(str);
		} // if UserMessageYN

	if (vPaF.Name[0] == 0)
		vPaF.SetName(Master->OutPath.Name);
	} // if vWarn

#ifdef WCS_BUILD_VNS
CoordSys csWGS84;

// Exporter CoordSys needs to be Geo WGS84
csWGS84.SetSystem("Geographic - WGS 84");

if (Master->Coords)
	rVal = Master->Coords->Equals(&csWGS84);

if (rVal == 0)
	UserMessageOK(msgWW, "Please set the export CoordSys to Geographic WGS 84");
#else
rVal = 1;
#endif // WCS_BUILD_VNS

return (rVal);

} // ExportFormatWW::SanityCheck

/*===========================================================================*/
